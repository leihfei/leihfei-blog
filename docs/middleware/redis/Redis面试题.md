# Redis面试题集合

## 1. Redis都有哪些使用场景？

缓存、分布式锁 、限流 、消息队列、活跃用户、排行榜



## 2. Redis有哪些功能？

1、基于本机内存的缓存

当调用api访问数据库时，假如此过程需要2秒，如果每次请求都要访问数据库，那将对服务器造成巨大的压力，如果将此sql的查询结果存到Redis中，再次请求时，直接从Redis中取得，而不是访问数据库，效率将得到巨大的提升，Redis可以定时去更新数据（比如1分钟）。

2、如果电脑重启，写入内存的数据是不是就失效了呢，这时Redis还提供了持久化的功能。

3、哨兵（Sentinel）和复制

Sentinel可以管理多个Redis服务器，它提供了监控、提醒以及自动的故障转移功能；

复制则是让Redis服务器可以配备备份的服务器；

Redis也是通过这两个功能保证Redis的高可用；

4、集群（Cluster）

单台服务器资源总是有上限的，CPU和IO资源可以通过主从复制，进行读写分离，把一部分CPU和IO的压力转移到从服务器上，但是内存资源怎么办，主从模式只是数据的备份，并不能扩充内存；

现在我们可以横向扩展，让每台服务器只负责一部分任务，然后将这些服务器构成一个整体，对外界来说，这一组服务器就像是集群一样。



## 3. Redis支持的数据类型有哪些？

1. hash
2. string
3. list
4. set
5. zset
6. stream
7. geo
8. hyperloglog
9. bitmap



## 4. Redis为什么是单线程的？

1. 代码更清晰，处理逻辑更简单；
2. 不用考虑各种锁的问题，不存在加锁和释放锁的操作，没有因为可能出现死锁而导致的性能问题；
3. 不存在多线程切换而消耗CPU；
4. 无法发挥多核CPU的优势，但可以采用多开几个Redis实例来完善；

一切都是为了提升性能



## 5. Redis真的是单线程的吗？

Redis6.0前： 单进程单线程

Redis6.0后： 单进程多线程

redis内部使用了基于epoll的多路复用模型，也可以多部署几个redis服务器解决单线程的问题；
redis主要的性能瓶颈是内存和网络；
内存好说，加内存条就行了，而网络才是大麻烦，内存可以加大内存，网络不好处理，所以redis6.0引入了多线程的概念，
redis6.0在网络IO处理方面引入了多线程，如网络数据的读写和协议解析等，需要注意的是，执行命令的核心模块还是单线程的。



## 6. Redis持久化有几种方式？

redis提供了两种持久化的方式，分别是RDB（Redis DataBase）和AOF（Append Only File）。

RDB，简而言之，就是在不同的时间点，将redis存储的数据生成快照并存储到磁盘等介质上；

AOF，则是换了一个角度来实现持久化，那就是将redis执行过的所有写指令记录下来，在下次redis重新启动时，只要把这些写指令从前到后再重复执行一遍，就可以实现数据恢复了。

其实RDB和AOF两种方式也可以同时使用，在这种情况下，如果redis重启的话，则会优先采用AOF方式来进行数据恢复，这是因为AOF方式的数据恢复完整度更高。

如果你没有数据持久化的需求，也完全可以关闭RDB和AOF方式，这样的话，redis将变成一个纯内存数据库，就像memcache一样。

## 7. Redis和 memecache 有什么区别？

1、Redis相比memecache，拥有更多的数据结构和支持更丰富的数据操作。

（1）Redis支持key-value，常用的数据类型主要有String、Hash、List、Set、Sorted Set。

（2）memecache只支持key-value。

2、内存使用率对比，Redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于memecache。

3、性能对比：Redis只使用单核，memecache使用多核。

4、Redis支持磁盘持久化，memecache不支持。

Redis可以将一些很久没用到的value通过swap方法交换到磁盘。

5、Redis支持分布式集群，memecache不支持。

## 8. 缓存击穿，缓存穿透，缓存雪崩？

### 1、缓存穿透

一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后盾系统查询（比如数据库等）

缓存穿透是指在高并发下查询key不存在的数据（不存在的key)，会穿过缓存查询数据库，导致数据库压力过大而宕机

解决方案：

- 对查询结果为空的情况也进行缓存，缓存时间(ttl)设置短一点，或者该key对应的数据insert了之后清理缓存

  问题： 缓存太多空值占用更多的空间

- 使用布隆过滤器，在缓存之前加一层布隆过滤器，在查询的时候先去布隆过滤器查询key是否存在，如果不存在就直接返回，存在继续查缓存和DB



### 2. 缓存雪崩

当服务器重启或者大量缓存key在某一个时间段失效，这样在失效的时候，也会给后端系统（DB）带来巨大压力

突然大量的key失效了或者redis重启，大量数据库访问，数据库可能会宕机

解决方案：

1. key的失效期分散开，不同key设置不同的过期时间
2. 设置二级缓存（数据可能存在不一致性）
3. 高可用（会造成脏读）



### 3. 缓存击穿

对于一些设置了过期时间的key，如果这些key可能在某个时间点被超高并发的访问，是一种非常“热”的数据，这个时候，需要考虑一个问题：缓存被“击穿”的问题，这个和缓存雪崩的区别是这里针对某一个key缓存，雪崩是很多key。

缓存在某个时间点过期的时候，恰好是这个时间点对这个key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB下载数据并写回缓存，这个时候大并发的请求可能瞬间就就把后端DB干废。

解决方案：

1. 分布式锁控制访问线程

   使用redis的setnx互斥锁进行判断，这样其他线程就处于等待状态，保证不会有大并发操作去使用数据库

2. 不设置超时时间，volatile-lru 的淘汰策略，但是会造成写一致性问题

   当数据库发生更新数据时，缓存中的数据不一定会及时更新，这样就会噪声缓存中的和数据库中数据不一致，应用从缓存中读取到的数据是脏数据，但是我们可以采取延时双删策略处理。

   

## 9. Redis分布式锁有什么缺陷？

Redis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。

Redis容易产生的几个问题：

1. 锁未被释放
2. B锁被A锁释放了
3. 数据库事务超时
4. 锁过期了，业务还没执行完
5. Redis主从复制的问题



## 10. Redis如何做内存优化？

1、缩短键值的长度

缩短值的长度才是关键，如果值是一个大的业务对象，可以将对象序列化成二进制数组；
首先应该在业务上进行精简，去掉不必要的属性，避免存储一些没用的数据；
其次是序列化的工具选择上，应该选择更高效的序列化工具来降低字节数组大小；
以JAVA为例，内置的序列化方式无论从速度还是压缩比都不尽如人意，这时可以选择更高效的序列化工具，如: protostuff，kryo等
2、共享对象池

对象共享池指Redis内部维护[0-9999]的整数对象池。创建大量的整数类型redisObject存在内存开销，每个redisObject内部结构至少占16字节，甚至超过了整数自身空间消耗。所以Redis内存维护一个[0-9999]的整数对象池，用于节约内存。 除了整数值对象，其他类型如list,hash,set,zset内部元素也可以使用整数对象池。因此开发中在满足需求的前提下，尽量使用整数对象以节省内存。

3、字符串优化

4、编码优化

5、控制key的数量