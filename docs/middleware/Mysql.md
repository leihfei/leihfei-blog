# 隔离级别相关

## 1. 事务

事务具有四个特征：

原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持久性（ Durability ）。

- 原子性： 事务中的操作要么全部成功，要么全部失败.
- 一致性： 一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态
- 隔离性： 一个事务的执行不能对其他事务形成干扰
- 持久性： 指一个事务一旦提交，它对数据库中的数据改变就应该永久性的，持久化到数据库了的概念。



## 2. Mysql隔离级别

隔离级别比较：可串行化>可重复读>读已提交>读未提交

隔离级别对性能的影响比较：可串行化>可重复读>读已提交>读未提交

隔离级别越高，所需要消耗的MySQL性能越大（如事务并发严重性），为了平衡二者，一般建议设置的隔离级别为可重复读，MySQL默认的隔离级别也是可重复读。



## 3. 并发事务出现的问题



更新丢失：当两个或多个事务更新同一行记录，会产生更新丢失现象，可以分为回滚覆盖和提交覆盖

- 回滚覆盖： 一个事务回滚操作，把其他事务已提交的数据覆盖了
- 提交覆盖： 一个事务提交操作，把其他事务已提交的数据覆盖了



脏读：一个事务读取到了另一个事务修改但未提交的数据



幻读： 一个事务中多次按相同条件查询，结果不一致。多次查询的结果和前面查询结果不同，多了或少了几行记录



不可重复读：一个事务中多次读取同一行数据，后面读取的数据和前面读取的不一致





## 4. 隔离级别

- **Read Uncommitted(读未提交)**
- **Read Committed（读已提交）**
- **Repeatable Read（可重读）（默认的隔离级别）**
- **Serializable（可串行化）**



### 4.1 Read Uncommitted（读未提交）

指所有事务可以看到别的事务未提交的数据

**解决了回滚覆盖类型的更新丢失，会引起脏读**



### 4.2 Read Committed（读已提交）

一个事务只能读取别的事务已经提交了的数据

大多数数据库默认隔离级别，如： SQL Server数据库

**解决了脏读，但是可能发生不可重复读问题（一个事务可能两次读取的数据结果不一致）**



### 4.3 Repeatable Read（可重读）（MySQL默认的隔离级别）

确保了同一个事务在多个实例并发读取数据时，会看到同样的数据行。

**解决了不可重复读，会导致幻读**



### 4.4 Serializable（可串行化）

最高的隔离级别，通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。



### 4.5 总结

> | **事务隔离级别**             | 回滚覆盖 |   脏读   | 不可重复读 | 提交覆盖 |   幻读   |
> | ---------------------------- | :------: | :------: | :--------: | :------: | :------: |
> | Read UnCommitted（读未提交） |    ×     | 可能发生 |  可能发生  | 可能发生 | 可能发生 |
> | Read Committed（读已提交）   |    ×     |    ×     |  可能发生  | 可能发生 | 可能发生 |
> | Repeatable Read（重复读）    |    ×     |    ×     |     ×      |    ×     | 可能发生 |
> | Serializable（串行化）       |    ×     |    ×     |     ×      |    ×     |    ×     |



### 4.5 mysql在RR隔离级别下如何解决幻读？

- 在快照读的情况下，mysql使用mvcc来避免幻读
- 在当前读(for update)的情况下，mysql通过next-key lock(行锁+间隙锁)锁来解决幻读，但是会降低并发度



快照读： 简单的select操作

当前读： 特殊的读操作，插入、更新、删除

```
select * from table where ? lock in share mode;
select * from table where ? for update;
insert into table values();
update table set ? where ?;
delete from table where ?;
```



## 5. Mysql锁

### 5.1 for update（排它锁）

- 当where条件的字段为索引或者主键时，for update锁是行锁
- 当where条件的字段为普通字段时，innodb是表锁



### 5.2 lock in share mode(共享锁)

允许不同事务之前共享加锁读取，但不允许其它事务修改或者加入排他锁
如果有修改必须等待一个事务提交完成，才可以执行，容易出现死锁

- 允许其他事务也增加共享锁读取
- 不允许其它事务增加排他锁（for update）
- 当事务同时增加共享锁时，事务的更新必须等待先执行的事务commit后才能执行，如果同时并发太大可能导致死锁

