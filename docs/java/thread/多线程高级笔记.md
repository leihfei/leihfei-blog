# 多线程高级笔记



# 笔记主要内容

记录相关并发工具类

1. 并发安全： 互斥同步、非互斥同步、无同步方案
2. 管理线程、提供效率
3. 线程写作



# 线程基础回顾

1. 能否直接杀死正在运行的线程？

​		答案是不能的，因为线程在持有的资源无法正常的释放



2. 守护线程： java规定，当所有的非守护线程退出后，整个JVM进程就会退出，意思就是守护线程不**不作数的**



3. 在主线程中，调用一句t.interrupt(),该线程能否抛出异常？

​      答案是不会的，因为只有申明了InterruptedExcepiton的才会被响应



​	4. 只有sleep,wait,join这几个函数才能响应中断异常

​		中断函数： Interrupted中断异常

​		t.interrupted()的精准含义应该是：**唤醒轻量级阻塞**，而不是字面意思”中断一个线程“



5. 轻量级阻塞与重量级阻塞

​	能够被中断的阻塞线程被称为轻量级阻塞，对应的线程状态为WAITING或者TIMED_WAITING;而像synchronized这种不能被中断的阻塞称为重量级阻塞，对应的状态是BLOCKED

![线程的状态迁移过程](https://lhf-note.oss-cn-hangzhou.aliyuncs.com/img%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E8%BF%81%E7%A7%BB%E8%BF%87%E7%A8%8B.png)

t.isInterrupted与Thread.interrupted()的区别

因为t.interrupted相当于给线程发送了一个唤醒信号，所以如果此时线程正好在WAITING或者TIMED_WAITING状态，就会抛出一个InterruptedException，并且线程被唤醒，而如果线程此时没有并阻塞，则线程什么都不会做，但在后续，线程可以判断自己是否可以收到过其他线程发来的中断信号，然后做一个对应的处理。

这两个函数都是线程用来判断自己是否收到过中断信号的，前者是非静态函数，后者是静态函数。二者的区别在于，**前者只是读取中断状态，不能修改状态；后者不仅读取中断状态，还会重置中断标志位**

线程默认的中断状态为false,读取之后，标志会被设置为false



**synchronized关键字其实是“给某个对象加了把锁”**

常见问题： 一个静态成员函数和一个非静态成员函数，都加了synchronized关键字，分别被两个线程调用，他们是否互斥？很明显，因为两把不同的锁，所以不会进行一个互斥。

synchronized关键字是可以加在任何对象的成员上面，这意味着这个对象可以是共享资源，同时也具备**锁**的功能

**synchronized的原理：**在java对象头里，有一块数据叫Mark Word. 在64位机器上，Mark Word是8字节（64）的，主要有两个重要字段：锁标志位和该锁的threadId，不同的JVM版本有不同的实现方式。













# 1. 线程池

​	**线程:** 程序执行流的最小执行单位，是行程中的实际运作单位，经常容易和进程这个概念混淆。那么，线程和进程究竟有什么区别呢？首先，进程是一个动态的过程，是一个活动的实体。简单来说，一个应用程序的运行就可以被看做是一个进程，而线程，是运行中的实际的任务执行者。可以说，进程中包含了多个可以同时运行的线程。	

​	**线程池：** Java中开辟出了一种管理线程的概念，这个概念叫做线程池，从概念以及应用场景中，我们可以看出，线程池的好处，就是可以方便的管理线程，也可以减少内存的消耗。

​		好处： 加快响应速度、合理利用CPU和内存、统一管理资源任务

​		使用场合： 服务器接收大量请求、开放中创建大量线程请求

## 1. 创建和停止线程池

​	构造函数的参数：

| 参数名          | 类型                     | 含义                                                    |
| --------------- | ------------------------ | ------------------------------------------------------- |
| corePoolSize    | int                      | 核心线程数                                              |
| maximumPoolSize | int                      | 最大线程数                                              |
| keepAliveTime   | long                     | 保持存活时间                                            |
| workQueue       | BlockingQueue            | 任务存储队列                                            |
| threadFactory   | ThreadFactory            | 当线程池需要新线程的时候，会使用ThreadFactory来生成线程 |
| Handler         | RejectedExecutionHandler | 当线程池无法接收所提交的任务的拒绝策略                  |

 - corePoolSize-核心线程数： 线程池在完成初始化之后，默认情况下，线程池中并没有任何线程，线程池会等待有任务到来时，在创建新线程执行任务。

 - maximumPoolSize-最大线程数：线程池有可能在线程核心数的基础上，额外的增加一些线程，但是这些线程增加也有一个上限，限定值就是maxPoolSize.

 - keepAliveTime-保持存活时间： 如果线程池当前的线程数多于corePoolSize,那么如果多于的线程空闲时间超过了keepAliveTime,他们会被回收

 - workQueue: 工作队列：
   - 直接交换： SynchronousQueue
   - 无界队列： LinkedBlockingQueue
   - 有界队列：ArrayBlockingQueue
   - 延时队列：DelayedWorkQueue
   - 优先级队列,无阻塞：PriorityBlockingQueue
   
 - 拒绝策略

   - AbortPolicy

     默认的拒绝策略，即丢弃任务并抛出RejectedExecutionException异常

     如果是比较关键的业务，推荐使用此拒绝策略，这样子在系统不能承载更大的并发量的时候，能够及时的通过异常发现。

     

   - DiscardPolicy

     ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。如果线程队列已满，则后续提交的任务都会被丢弃，且是静默丢弃。

     使用此策略，可能会使我们无法发现系统的异常状态。建议是一些无关紧要的业务采用此策略。例如，博客网站统计阅读量就是采用的这种拒绝策略。

     

   - DiscardOldestPolicy

     ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新提交被拒绝的任务。

     此拒绝策略，是一种喜新厌旧的拒绝策略。是否要采用此种拒绝策略，还得根据实际业务是否允许丢弃老任务来认真衡量。

     

   - CallerRunsPolicy

     ThreadPoolExecutor.CallerRunsPolicy：由调用线程执行该任务。拒绝了，让调用方线程来执行任务，并且可以让提交任务速度降低

     

### 线程添加规则

  1. 如果线程数小于corePoolSize,即使其他线程处于空闲状态，也会创建一个新的线程来执行新任务。

  2. 如果线程数等于或大于corePoolSize，但小于maximumPoolSize，则将任务放入队列。

  3. 如果队列已满，当线线程数小于maximumPoolSize,那么创建新的线程来执行任务。

  4. 如果队列已满，并且线程数大于或等于maximumPoolSize,那么执行拒绝任务。

     

     流程图如下：

     ![线程池任务执行流程图](https://lhf-note.oss-cn-hangzhou.aliyuncs.com/img/202110201033400.png)

     
     
     

### 增减线程的特点



1. 通过设置corePoolSize和maximumPoolSize相同，就可以创建固定大小的线程池。
2. 线程池希望保持较少的线程数，并且只有负载变得很大的时候才增加它
3. 通过设置maximumPoolSize为很高的值，如Integer.MAX_VALUE,可以允许线程池容纳任意数量的并发任务
4. 当只有在队列填满的时候才创建多余corePoolSize的线程，所以如果使用了无界队列（LinkedBlockingQueue），那么线程数就不会超过corePoolSize



### 线程池有哪几种工作队列？

1、ArrayBlockingQueue

是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。

2、LinkedBlockingQueue

一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列

3、SynchronousQueue

一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。

4、PriorityBlockingQueue

一个具有优先级的无限阻塞队列。


### 线程创建JDK提供几种方式

#### 1.newFixedThreadPool 单线程化的Executor

```java

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * @author leihfei
 * @date 2021-10-19
 * newFixedThreadPool
 */
public class FixedThreadPoolDemo {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newFixedThreadPool(4);
        for (int i = 0; i < 1000; i++) {
            executorService.execute(new Task1(i));
        }
        executorService.shutdown();
    }
    static class Task1 implements Runnable{
        int i = 0;
        public Task1(int _i){
            i = _i;
        }
        @Override
        public void run() {
            System.out.println(Thread.currentThread().getName() + "  i=" + i);
        }
    }
}

```

**源码分析**：

```java
    public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>());
    }
    //主要为： 创建了corePoolSize和maxPoolSize相等大小的线程池，并且keepAliveTime为0，队列为无界队列
```



**注意： **由于传进去的LinkedBlockingQueue是没有容量限制，所有当请求越来越多的时候，并且无法及时处理完毕，也就是请求堆积的时候，会容易造成OOM。



#### 2. newSingleThreadExecutor 固定数目线程的线程池（队列数没有限制）

```java

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * @author leihfei
 * @date 2021-10-19
 * newSingleThreadExecutor 就是单独线程
 */
public class newSingleThreadExecutorDemo {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newSingleThreadExecutor();
        for (int i = 0; i < 1000; i++) {
            executorService.execute(new FixedThreadPoolDemo.Task1(i));
        }
        executorService.shutdown();
    }

    static class Task1 implements Runnable {
        int i = 0;

        public Task1(int _i) {
            i = _i;
        }
        
        @Override
        public void run() {
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + "  i=" + i);
        }
    }
}
输出结果： 
pool-1-thread-1  i=926
pool-1-thread-1  i=927
pool-1-thread-1  i=928
pool-1-thread-1  i=929
pool-1-thread-1  i=930
```

源码：

```java
    public static ExecutorService newSingleThreadExecutor() {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue<Runnable>()));
    }
```



**结论：** newSingleThreadExecutor和newFixedThreadExecutor原理是一样的，只是将corePoolSize和maxPoolSize设置为固定大小，也同样会造成OOM。



#### 3.newCachedThreadPool 可缓存的线程池（线程数没有限制）



```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * @author leihfei
 * @date 2021-10-19
 */
public class CachedThreadPoolDemo {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i < 1000; i++) {
            executorService.execute(() -> System.out.println(Thread.currentThread().getName()));
        }
        executorService.shutdown();
    }
}
输出结果： 
pool-1-thread-94
pool-1-thread-13
pool-1-thread-198
pool-1-thread-93
```

源码：

```java
    public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue<Runnable>());
    }
```

**结论：**看出没有corePoolSize,maxPoolSize还是整形的最大值，workQueue是直接交换队列，那么就会一个任务直接创建一个线程来直接处理。

#### 4.newScheduledThreadPool支持定时及周期性的任务执行的线程池

```java

import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * @author leihfei
 * @date 2021-10-19
 */
public class ScheduleThreadPoolDemo {
    public static void main(String[] args) {
        ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(10);
        // 延时之后，定时执行任务
//        scheduledExecutorService.scheduleAtFixedRate(() ->
//                        System.out.println(Thread.currentThread().getName()),
//                1,
//                3,
//                TimeUnit.SECONDS);

//        scheduledExecutorService.schedule(() ->
//                        System.out.println(Thread.currentThread().getName()),
//                1,
//                TimeUnit.SECONDS);

        // 延时之后，执行任务，并且delay指的是上一个任务执行结束之后，delay时间之后在执行新的任务
        scheduledExecutorService.scheduleWithFixedDelay(() ->
                        System.out.println(Thread.currentThread().getName()),
                0,
                3,
                TimeUnit.SECONDS);
    }
}
```

源码：

```java
    public ScheduledThreadPoolExecutor(int corePoolSize) {
        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
              new DelayedWorkQueue());
    }
```

**注意**：

scheduleAtFixedRate： 表示延时后，定时执行任务

scheduleWithFixedDelay: 表示延时后，当上一个任务执行完毕之后，延时delay时间后执行新的任务



#### 5. workStealingPool

​	特点： 子任务，窃取数据、相互配合

​	使用场景： 递归



####  submit和execute的区别

execute适用于不需要关注返回值的场景，只需要将线程丢到线程池中去执行就可以了。

submit方法适用于需要关注返回值的场景



### 设置线程池中的线程数多少合适?

- CPU密集型（加密，计算Hash等）： 最佳线程数为CPU核心数的1-2倍
- 耗时IO型（读写文件，网络等）： 最佳线程数一般会大于CPU核心很多倍，以JVM线程监控显示繁忙情况为依据，保证线程空闲可以衔接上，参考Brain Goetz推荐的设置方法： **线程数=CPU核心数 *（1+平均等待时间/平均工作时间）**
- 根据程序进行压测得到数据，在进行设置



### 线程是自动还是手动创建好？

**建议线程池手动创建**，可以自己控制核心数等，队列，灵活控制



## 2. 常见的线程池的特点和用法

### 参数情况

| 参数          | FixedThreadPool     | CachedThreadPool  | ScheduledThreadPool | SingleThreaded      |
| ------------- | ------------------- | ----------------- | ------------------- | ------------------- |
| corePoolSize  | 构造器传递          | 0                 | 构造器传递          | 1                   |
| maxPoolSzie   | 跟corePoolSize一致  | Integer.MAX_VALUE | Integer.MAX_VALUE   | 1                   |
| keepAliveTime | 0 seconds           | 60 seconds        | 0 seconds           | 0 seconds           |
| workQueue     | LinkedBlockingQueue | SynchronousQueue  | DelayedWorkQueue    | LinkedBlockingQueue |

FixedThreadPool和SingleThreaded为什么选择LinkedBlockingQueue作为工作队列？

​	原因： 因为Fixed,Single线程池都需要借助LinkedBlockingQueue来满足大量任务的情况。



CachedThreadPool为什么选择SynchronousQueue作为工作队列？

​	原因： 不需要将任务放入队列中，每次都是产生新的线程来直接处理。



ScheduledThreadPool为什么选择DelayedWorkQueue作为工作队列？

​	原因： DelayedWorkQueue是延时队列。



### 停止线程的正确方法

- shutdown

  优雅的关闭线程池，shutdown停止之后，线程池会继续执行原来已经提交的任务，但是拒绝shutdown之后的任务，抛出异常。可以调用isShutdown来查看

- isShutdown

  判断是否调用shutdown

- isTerminated

  判断整个程序时候结束

- awaitTermination

  检测多少时间之后线程池是否结束,返回true/false

- shutdownNow

  立刻关闭线程池，调用stutdownNow之后，正在执行的线程会收到**interrupted**中断信号，还没有执行的线程会直接结束并且返回成```List<Runnable>```，以便于后续继续执行

  

## 3. 拒绝策略

#### 拒绝时机

- 当Executor调用shutdown后，新提交的任务会直接拒绝
- 当Executor对最大线程和工作队列容量使用是有界队列，并且饱和时会拒绝

#### 拒绝策略

- AbortPolicy

  默认的拒绝策略，即丢弃任务并抛出RejectedExecutionException异常

  如果是比较关键的业务，推荐使用此拒绝策略，这样子在系统不能承载更大的并发量的时候，能够及时的通过异常发现。

  

- DiscardPolicy

  ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。如果线程队列已满，则后续提交的任务都会被丢弃，且是静默丢弃。

  使用此策略，可能会使我们无法发现系统的异常状态。建议是一些无关紧要的业务采用此策略。例如，本人的博客网站统计阅读量就是采用的这种拒绝策略。

  

- DiscardOldestPolicy

  ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新提交被拒绝的任务。

  此拒绝策略，是一种喜新厌旧的拒绝策略。是否要采用此种拒绝策略，还得根据实际业务是否允许丢弃老任务来认真衡量。

  

- CallerRunsPolicy

  ThreadPoolExecutor.CallerRunsPolicy：由调用线程执行该任务。拒绝了，让调用方线程来执行任务，并且可以让提交任务速度降低

  

## 4. 钩子方法

​		beforExecute钩子方法

​		

## 5. 实现原理、源码分析
#### 线程池组成部分
- 线程池管理器
- 工作线程
- 任务队列
- 任务接口（Task）

![image-20211019160007789-16346332568392](https://lhf-note.oss-cn-hangzhou.aliyuncs.com/img/202110201038480.png)

#### 线程池实现任务复用的原理

相同线程执行不同的任务，不是通过start来启动任务的。



**查看execute方法：**

```java
public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
        /*
         * Proceed in 3 steps:
         *
         * 1. If fewer than corePoolSize threads are running, try to
         * start a new thread with the given command as its first
         * task.  The call to addWorker atomically checks runState and
         * workerCount, and so prevents false alarms that would add
         * threads when it shouldn't, by returning false.
         *
         * 2. If a task can be successfully queued, then we still need
         * to double-check whether we should have added a thread
         * (because existing ones died since last checking) or that
         * the pool shut down since entry into this method. So we
         * recheck state and if necessary roll back the enqueuing if
         * stopped, or start a new thread if there are none.
         *
         * 3. If we cannot queue task, then we try to add a new
         * thread.  If it fails, we know we are shut down or saturated
         * and so reject the task.
         */
        int c = ctl.get();
        if (workerCountOf(c) < corePoolSize) {
        	// 添加到工作队列中
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        if (isRunning(c) && workQueue.offer(command)) {
            int recheck = ctl.get();
            if (! isRunning(recheck) && remove(command))
                reject(command);
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        else if (!addWorker(command, false))
            reject(command);
    }
    
```

![image-20211019161103327-16346332651513](https://lhf-note.oss-cn-hangzhou.aliyuncs.com/img/202110201039594.png)

创建了一个Worker的类，并且将任务提交了过去

![image-20211019161201917-16346332709074](https://lhf-note.oss-cn-hangzhou.aliyuncs.com/img/202110201039842.png)

由于将this传递过去，那么将会执行本类中的run方法

![image-20211019161304476-16346332766825](https://lhf-note.oss-cn-hangzhou.aliyuncs.com/img/202110201039033.png)

继续执行runWorker方法

![image-20211019161352537-16346332807846](https://lhf-note.oss-cn-hangzhou.aliyuncs.com/img/202110201039372.png)





## 6. 使用线程池的注意点

#### 线程池状态

**RUNNING**：能接受新提交的任务，并且也能处理阻塞队列中的任务；

**SHUTDOWN**：关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务。

**STOP**：不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。在线程池处于 `RUNNING` 或 `SHUTDOWN` 状态时，调用`shutdownNow()` 方法会使线程池进入到该状态；

**TIDYING**：如果所有的任务都已终止了，workerCount (有效线程数) 为0，线程池进入该状态后会调用 `terminated()` 方法进入`TERMINATED` 状态。

**TERMINATED**：在`terminated()`方法执行完后进入该状态



各个状态之间的切换示意图：

![image-20211019161518767-16346332897627](https://lhf-note.oss-cn-hangzhou.aliyuncs.com/img/202110201045574.png)

**Thread状态：**

![image-20220214142600802](https://lhf-note.oss-cn-hangzhou.aliyuncs.com/img/image-20220214142600802.png)



#### 注意事项

线程池使用FutureTask的时候如果拒绝策略设置为了 DiscardPolicy和DiscardOldestPolicy并且在被拒绝的任务的Future对象上调用无参get方法那么调用线程会一直被阻塞。



## 7.  最佳实践

- 不使用系统自带的四个Executors
- 设置`UncaughtExceptionHandler`
- 优雅的关闭线程池



# 2. ThreadLocal

##  2.1 ThreadLocal使用场景

- 每个线程独享： 通常是工具类（线程不安全），典型的是SimpleDateFormat和Random

  ```
  ThreadLocal.withInitial(() -> new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"));
  ```

- 每个线程需要保存全局变量： 如在接口调用中，拦截器处理用户信息，后面的每个方法都可以获取到用户信息,避免参数多次传递麻烦

  ```java
  ThreadLocal<String> threadLocal = new ThreadLocal<>();
  threadLocal.set("ddd");
  threadLocal.get();
  ```

  

**总结：**

1. 上某个需要用到的对象在线程间隔离（每个线程都有自己独立的对象）
2. 在任何方法中都可以轻松的获取到对象



**好处**

- 达到线程安全
- 避免传参的繁琐： ThreadLocal使得代码耦合度更低，代码更优雅
- 不需要加锁，执行效率高
- 更高效的利用内存、节省开销： 避免重复创建对象



## 2.2 源码

搞清楚Thread、ThreadLocal、ThreadLocalMap三者的关系

每个Thread对象都持有一个ThreadLocalMap成员变量

![image-20211020135447028](https://lhf-note.oss-cn-hangzhou.aliyuncs.com/img/202110201354141.png)

原理图：

![image-20211020135858268](https://lhf-note.oss-cn-hangzhou.aliyuncs.com/img/202110201358358.png)

**说明**： Thread中存在一个ThreadLocalMap变量，ThreadLocalMap存在多个ThreadLocal，ThreadLocalMap下存在一个Entry[] table数组，用于存储ThreadLocal

```java
   static class Entry extends WeakReference<ThreadLocal<?>> {
            /** The value associated with this ThreadLocal. */
            Object value;

            Entry(ThreadLocal<?> k, Object v) {
                super(k);
                value = v;
            }
        }
```

Entry[] 数组，存储ThreadLocal数据

**注意：Entry类继承了WeakReference弱引用**

- StrongReference: 强引用，new出来对象，只要引用存在，虚拟机就不会回收，直到报OOM

- SoftReference： 软引用，软引用是用来描述一些非必需但仍有用的对象。在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。这种特性常常被用来实现缓存技术，比如网页缓存，图片

  缓存等

- WeakReference: 弱引用 ，无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收

- PhantomReference: 虚引用 ，无法使用，基本就是在JVM回收时，能有个通知





## 2.3 重要方法

- initalvalue() 初始化

  通常调用1次，remove()，还会在初始化

  不覆盖，会直接返回null

  

- get() 获取值

  ```java
  /**
   * Returns the value in the current thread's copy of this
   * thread-local variable.  If the variable has no value for the
   * current thread, it is first initialized to the value returned
   * by an invocation of the {@link #initialValue} method.
   *
   * @return the current thread's value of this thread-local
   */
  public T get() {
  	// 获取当前线程
      Thread t = Thread.currentThread();
      // 获取当前得到的线程中的ThreadLocamMap， return t.threadLocals;
      ThreadLocalMap map = getMap(t);
      if (map != null) {
      	// 得到map中的对象，需要传递当前ThreadLocal对象
          ThreadLocalMap.Entry e = map.getEntry(this);
          if (e != null) {
              @SuppressWarnings("unchecked")
              T result = (T)e.value;
              return result;
          }
      }
      // get之前没有进行set，那么需要进行初始化
      return setInitialValue();
  }
  ```

  获取Entry对象

  ```java
  /**
   * Get the entry associated with key.  This method
   * itself handles only the fast path: a direct hit of existing
   * key. It otherwise relays to getEntryAfterMiss.  This is
   * designed to maximize performance for direct hits, in part
   * by making this method readily inlinable.
   *
   * @param  key the thread local object
   * @return the entry associated with key, or null if no such
   */
  private Entry getEntry(ThreadLocal<?> key) {
      // 得到hash值
      int i = key.threadLocalHashCode & (table.length - 1);
      // 从Entry类中的table数组中获取到当前的Entry值，也就是我们ThreadLcoal存储的值
      Entry e = table[i];
      if (e != null && e.get() == key)
          return e;
      else
          return getEntryAfterMiss(key, i, e);
  }
  ```

- set() 设置值

  ```java
  public void set(T value) {
      Thread t = Thread.currentThread();
      ThreadLocalMap map = getMap(t);
      if (map != null)
          map.set(this, value);
      else
          createMap(t, value);
  }
  ```

- remove 删除当前线程的ThreadLocal

  ```java
  public void remove() {
      ThreadLocalMap m = getMap(Thread.currentThread());
      if (m != null)
      	// 删除的是调用者ThreadLocal
          m.remove(this);
  }
  ```



**ThreadLocalMap类**

 类似于HashMap,都维护了一个数组，但是注意解决hash冲突的方式不一样

 HashMap： 拉链法+红黑树

ThreadLocalMap: 线性探测法

​		所谓线性探测，就是根据初始 key 的 hashcode 值确定元素在 table 数组中的位置，如果发现这个位置上已经被其他的 key 值占用，则利用固定的算法寻找一定步长的下个位置，依次判断，直至找到能够存放的位置。

```java
// 计算hash值
int h = key.threadLocalHashCode & (len - 1);
// 判断如果该位置已经有值
while (table[h] != null)
	// 进行继续添查找下一个数据为空的位置
	h = nextIndex(h, len);
        
   
/**
* Increment i modulo len.
*/
private static int nextIndex(int i, int len) {
  return ((i + 1 < len) ? i + 1 : 0);
}
```





## 2.4 内存泄漏

ThreadLocalMap中的成员变量是一个Entry[] table

```java
static class Entry extends WeakReference<ThreadLocal<?>> {
    /** The value associated with this ThreadLocal. */
    Object value;

    Entry(ThreadLocal<?> k, Object v) {
        super(k);
        value = v;
    }
}
```

注意观察到Entry继承WeakReference，WeakReferece是一个弱引用，弱引用可以被jvm垃圾回收直接回收。

**Java引用类型**

- 强引用： new Object()

- 软引用： 软引用是用来描述一些非必需但仍有用的对象。**在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常**。

- 弱引用： 弱引用的引用强度比软引用要更弱一些，**无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收**。在 JDK1.2 之后，用 java.lang.ref.WeakReference 来表示弱引用

- 虚引用：虚引用是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收，在 JDK1.2 之后，用 PhantomReference 类来表示，通过查看这个类的源码，发现它只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是说将永远无法通过虚引用来获取对象，虚引用必须要和 ReferenceQueue 引用队列一起使用。主要用来做被回收后得到通知。

  

JDK已经考虑到了这个问题，所以在set、remove、rehash方法中会扫描key为null的Entry，并把对应的value设置为null，这样value对象就会被回收。

![image-20211020142524583](https://lhf-note.oss-cn-hangzhou.aliyuncs.com/img/202110201425702.png)

但是还是会存在问题，因为可能在开发中不会去调到这些方法。所以阿里的开发规范中，**要求我们使用完毕之后手动的进行threadLocal.remove()方法进行回收。**

**注意**：

实际开发中： 用拦截器的方式设置ThreadLocal，那么也应该在拦截器中对该ThreadLocal进行remove()

注意基本类型的装箱拆箱问题

不应该在ThreadLocal存储static静态对象



#  3. 锁

## 3.1 Lock接口

​	为什么synchronized不够用？

```
1. 效率低： 锁释放情况少（执行完毕，出异常），试图获取锁时不能设定超时、不能中断一个正在试图获取锁的线程
2. 不够灵活（读写锁更灵活）： 加锁和释放的时机单一，每个锁仅有一个单一条件（某个对象）
3. 无法知道是否成功获取到锁
```

由于synchronized的问题，那么lock锁就来了。



**重点有四个方法：**

​	lock(): 普通的获取锁，无法得到时就等待,**lock出异常不会自动释放锁**，**lock方法不能被中断**，一旦陷入死锁，lock就会被陷入永久等待

​	tryLock() 尝试获取锁，获取不到就立即返回false

​	tryLock(long time,TimeUnit unit) 尝试获取锁，但是在规定时间内无法获取锁，那么也直接返回false

​	lockInterruptibly() 等待锁的时间默认设置为无限，但是是可以被响应中断

​	unlock() 解锁，需要写在finally中，保证都能释放锁



**lock锁是具有可见性保障的**

可见性： a线程修改了会同时反映到其他线程，保证其他线程可见



## 3.2 锁的分类

![image-20211020152942630](https://lhf-note.oss-cn-hangzhou.aliyuncs.com/img/202110201529795.png)

互斥同步锁的劣势：

- 阻塞和唤醒带来的性能劣势
- 永久阻塞： 如果持有锁的线程被永久阻塞，比如入到了无限循环、死锁等活跃性问题，那么等待该线程释放锁的那几个悲催的线程，将永远也得不到执行
- 优先级反转



## 3.3 乐观锁和悲观锁

​	悲观锁：默认其他线程会来抢锁，所以对资源都直接加锁

​	乐观锁： 某人其他线程不会抢夺锁，在修改的时候在检查是否被别的线程修改，一般是利用CAS实现的；一般**原子类，并发容器类,Git版本管理**。AtomicInteger等



**开销对比：**

​	悲观锁的原始开销要高于乐观锁，但是特点是**一劳永逸**，临界区持锁的时间就算越来越差，也不会对互斥锁的开销造成印象

​	乐观锁如果自旋时间很长或者不断重试，那么消耗的资源会越来越多



**使用场景**

​	悲观锁： 适合并发写入多的情况，适用于临界区持锁时间比较长的情况，悲观锁可以避免大量的无用自旋消耗：

   - 临界区有IO操作

   - 临界区代码复杂或者循环量大

   - 临界区竞争激烈

     乐观锁：

     ​	适合并发**写入少，大部分是读取**的场景，不加锁的读取性能大幅度提高



## 3.4 可重入锁和非可重入锁，以ReentrantLock

​	可重入锁： 可以多次获取到同一把锁（ReentrantLock,synchronized）

​	好处： 避免死锁，提高封装性

​	isHeldByCurrentThread可以看出锁是否被当前线程持有

​	getQueueLength可以返回当前正在等待这把锁的队列有多长



ReentrantLock实现：AQS,CAS



## 3.5 公平锁和非公平锁

公平是指按照线程请求的顺序来分配锁；非公平是指：不完全按照请求的顺序，在一定情况下，可以插队。

**注意**：非公平也同样不提倡“插队”行为，这里的非公平，指的是在**合适的时机**插队，而不是盲目的插队

非公平目的是为了提高效率，避免唤醒带来的空档期



**ReentrantLock默认是非公平的，可以通过构造函数指定为公平**

```java
import java.util.Random;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @author leihfei
 * @date 2021-10-20
 * 演示公平锁和非公平锁
 * 实例解释：
 *  默认非公平锁： 那么第一次打印之后，会立即打印第二次，并且打印完毕
 *  公平锁： 第一次打印，然后打印第二个线程第一次，第三个线程第一次.....,第二次打印，打印完毕，第二个线程打印，打印完毕....
 */
public class FairLock {

    public static void main(String[] args) {
        PrintQueue queue = new PrintQueue();
        Thread[] threads = new Thread[10];
        for (int i = 0; i < 10; i++) {
            threads[i] = new Thread(new Job(queue));
        }
        for (int i = 0; i < threads.length; i++) {
            Thread thread = threads[i];
            thread.start();
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    static class Job implements Runnable {
        PrintQueue printQueue;

        public Job(PrintQueue printQueue) {
            this.printQueue = printQueue;
        }

        @Override
        public void run() {
            System.out.println(Thread.currentThread().getName() + "开始打印");
            printQueue.printObj(new Object());
            System.out.println(Thread.currentThread().getName() + "打印完毕");
        }
    }

    static class PrintQueue {
        // 构造函数传递参数： 默认非公平，true=公平锁，false=非公平
        private Lock lock = new ReentrantLock();

        private void printObj(Object document) {
            lock.lock();
            try {
                int duration = new Random().nextInt(3);
                System.out.println(Thread.currentThread().getName() + " 第一次：正在打印,需要" + duration + "秒");
                Thread.sleep(duration * 1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
            lock.lock();
            try {
                int duration = new Random().nextInt(5);
                System.out.println(Thread.currentThread().getName() + " 第二次：正在打印,需要" + duration + "秒");
                Thread.sleep(duration * 1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        }
    }
}

```

打印结果： 非公平

```
Thread-0开始打印
Thread-0 第一次：正在打印,需要1秒
Thread-1开始打印
Thread-2开始打印
Thread-0 第二次：正在打印,需要3秒
Thread-0打印完毕
Thread-1 第一次：正在打印,需要0秒
Thread-1 第二次：正在打印,需要4秒
Thread-1打印完毕
Thread-2 第一次：正在打印,需要0秒
Thread-2 第二次：正在打印,需要4秒
Thread-2打印完毕

```

打印结果： 公平

```
Thread-0开始打印
Thread-0 第一次：正在打印,需要2秒
Thread-1开始打印
Thread-2开始打印
Thread-1 第一次：正在打印,需要0秒
Thread-2 第一次：正在打印,需要0秒
Thread-0 第二次：正在打印,需要0秒
Thread-0打印完毕
Thread-1 第二次：正在打印,需要0秒
Thread-1打印完毕
Thread-2 第二次：正在打印,需要2秒
Thread-2打印完毕
```



**特例**

针对tryLock方法，它是不遵守设定的公平规则的

​	当有线程执行tryLock()的时候，一旦有线程释放了锁，那么正在tryLock的线程就能立即获取到锁，即使它之前已经有其他线程在等待队列中了



**优缺点：**

|          | 优势                                                       | 劣势                                               |
| -------- | ---------------------------------------------------------- | -------------------------------------------------- |
| 公平锁   | 每个公平平等，每个线程在等待一段时间之后，总会有执行的机会 | 更慢，吞吐量小                                     |
| 非公平锁 | 更快，吞吐量大                                             | 有可能产生线程饥饿，也就是某些线程长时间得不到执行 |

公平锁原理图：

![](https://lhf-note.oss-cn-hangzhou.aliyuncs.com/img/202110202037968.png)



## 3.6 共享锁和排他锁： 以ReentrantReadWriteLock读写锁

​	排它锁： 又称独占锁，独享锁

​	共享锁： 有称为读锁，获取共享锁之后，可以查看但是无法修改和删除数据，其他线程也可以获取到共享锁，也是查看但是无法修改和删除数据

​	共享锁和排它锁的典型是读写锁**ReentrantReadWriteLock**,其中读锁是共享锁，写锁是排它锁



**读写锁的规则**

1. 多个线程值申请读锁，都可以申请到
2. 如果有一个线程占用了读锁，其他线程要申请写锁，就必须等待读锁释放
3. 如果有一个线程占用了写锁，其他线程想要申请读写锁，都必须等待

**结论： 要么一个或多个线程同时有读锁，要么一个线程有写锁；（要么多读，要么一写，两者不可能同时出现）**

```java

import java.util.concurrent.locks.ReentrantReadWriteLock;

/**
 * @author leihfei
 * @date 2021-10-20
 * 读写锁
 */
public class ReentrantReadWriteLockDemo {
    private static ReentrantReadWriteLock reentrantReadWriteLock = new ReentrantReadWriteLock();
    // 读写锁
    private static ReentrantReadWriteLock.ReadLock readLock = reentrantReadWriteLock.readLock();
    private static ReentrantReadWriteLock.WriteLock writeLock = reentrantReadWriteLock.writeLock();

    private static void read() {
        readLock.lock();
        try {
            System.out.println(Thread.currentThread().getName() + "得到了读锁，正在读取中");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        } finally {
            readLock.unlock();
            System.out.println(Thread.currentThread().getName() + "释放了读锁");
        }
    }

    private static void write() {
        writeLock.lock();
        try {
            System.out.println(Thread.currentThread().getName() + "得到写锁，正在写入");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        } finally {
            writeLock.unlock();
            System.out.println(Thread.currentThread().getName() + "释放了写锁");
        }
    }

    public static void main(String[] args) {
        new Thread(() -> read(), "Thread1").start();
        new Thread(() -> read(), "Thread2").start();
        new Thread(() -> write(), "Thread3").start();
        new Thread(() -> write(), "Thread4").start();
    }
}
```



​	允许插队的情况： 容易引起饥饿，但是效率较高

​		大量线程在读，有个线程在队列中想要获取写锁，但是读锁未释放的情况下，其他读线程一直在插队读取，造成了写线程一直无法执行

​	不允许插队： 避免饥饿，直接进入排队

​	**ReentrantReadWriteLock**

​	公平情况下：不允许插队

​	非公平情况下： 分为两种情况，

- 写锁可以随时插队
- 读锁仅在等待队列头结点不是写锁的时候可以插队

**源码**

公平锁情况： 

![image-20211020210355129](https://lhf-note.oss-cn-hangzhou.aliyuncs.com/img/202110202104048.png)



​		非公平锁情况：

![image-20211020210613573](https://lhf-note.oss-cn-hangzhou.aliyuncs.com/img/202110202106810.png)

**升降级**： 支持锁的降级，不支持升级，从写锁降级到读锁



**总结**： 

	1. 获取锁策略： 要么多读，要么一写
	2. 插队策略： 为了防止饥饿，读锁不能插队；公平锁：全部不能插队，非公平锁： 写锁可以插队，读锁需要在排队队列头结点是读锁才能插队，否则不能插队。
	3. 升降级策略： 只能降级，不能升级



使用场景： 适用于读多写少的场景



## 3.7 自旋锁和阻塞锁

优点： 避免上下文切换

缺点： 长时间占有CPU资源，造成资源浪费

原子类中很多都是自旋锁



原理： 就是利用CAS



使用场景： 用于多核服务器，在并发度不高的情况下，比阻塞锁效率高；适用于在临界区比较短小的情况，否则如果临界区很大（线程一旦获取锁，很长时间才释放），那么也不合适。









## 3.8 可中断锁： 就是可以响应中断的锁

synchronized： 不可中断锁

ReentrantLock： 可中断锁







## 3.9 锁优化

JVM优化：

	- 自旋锁和自适应
	- 锁消除
	- 锁粗化



**如何在写代码中优化锁和提高性能**

1. 缩小同步代码块
2. 尽量不要锁住方法
3. 减少锁的次数
4. 避免人为制造**热点**
5. 锁中不要再包含锁
6. 选择适合的锁的类型或者合适的工具类









# 4.  atomic包

## 4.1 什么是原子类，有什么作用？

​	一个操作是**不可中断**的，即使在多线程下也可以保证

​	原子的粒度更细： 原子变量可以把竞争范围缩小到变量级别，这是我们可以获得的最细粒度的情况，通常锁的粒度要大于原子变量的粒度

​	效率更高： 通常，使用原子类的效率会比使用锁的效率更高，但是在高度竞争的情况下会出现以外，因为原子类**利用CAS**，不断的自旋导致的。

​	主要在：**java.util.concurrent.atomic.**包中



## 4.2 6类原子类

| 原子类型                          | 具体类型                                                     |
| --------------------------------- | ------------------------------------------------------------ |
| Atomic*基本类型原子类             | AtomicInteger、AtomicLong、AtomicBoolean                     |
| Atomicc*Array数组类型原子类       | AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray    |
| Atomic*Reference引用类型原子类    | AtomicReference、AtomicStampedReference、AtomicMarkableReference |
| Atomic*FieldUpdater升级类型原子类 | AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、AtomicReferenceFieldUpdater |
| Adder累加器                       | LongAdder、DoubleAdder                                       |

![image-20211021100700437](https://lhf-note.oss-cn-hangzhou.aliyuncs.com/img/202110211007551.png)



## 4.3 Atiomic*基本类型原子类

 **AtomicInteger原子类**

常用方法：

- public final int get() // 获取当前值

- public final int getAndSet(int newValue) // 获取当前的值，并设置新的值

- public final int getAndIncrement() // 获取当前值，并自增

- public final int getAndDecrement() // 获取当前值，并自减

- public final int getAndAdd(int delta) // 获取当前的值，并加上预期值

- bool compareAndSet(int expect,int update)// 如果输入的值等于预期值，则以原子方式将该值设置为输入的值（update)

  ```java
  import java.util.concurrent.atomic.AtomicInteger;
  
  /**
   * @author leihfei
   * @date 2021-10-21
   * 演示AtomicInteger基本用法，对比非原子类的线程安全问题，使用了原子类之后，不需要枷锁，也可以保证
   * 线程安全
   */
  public class AtomicIntegerDemo1 implements Runnable {
      private static final AtomicInteger atomicInteger = new AtomicInteger();
  
      public void incrementAtomic() {
          atomicInteger.getAndIncrement();
      }
  
      private static volatile int basicCOunt = 0;
  
      public void incrementBasic() {
          basicCOunt++;
      }
  
      @Override
      public void run() {
          for (int i = 0; i < 10000; i++) {
              incrementAtomic();
              incrementBasic();
          }
      }
  
      public static void main(String[] args) throws InterruptedException {
          AtomicIntegerDemo1 atomicIntegerDemo1 = new AtomicIntegerDemo1();
          Thread t1 = new Thread(atomicIntegerDemo1);
          Thread t2 = new Thread(atomicIntegerDemo1);
          t1.start();
          t2.start();
          t1.join();
          t2.join();
          System.out.println("原子类：" + atomicInteger.get());
          System.out.println("普通变量:" + basicCOunt);
      }
  }
  ```

  **运行结果：**

  原子类：20000
  普通变量:17661

  



## 4.4 Atomic*Array数组类原子类

**AtomicIntegerArray**就是基本原子类型的数组形态

其底层的CAS函数还是使用compareAndSwapInt，但是把数组下标i转化成对应的内存偏移量，所用的方法和之前的AtomicInteger不太一样；



**注意：** 这里并不是针对整个数组是原子操作的，而是这对数组中的一个元素是原子操作而言



```java
import java.util.concurrent.atomic.AtomicIntegerArray;

/**
 * @author leihfei
 * @date 2021-10-21
 * 演示AtomicIntegerArray基本用法，对比非原子类的线程安全问题，使用了原子类之后，不需要枷锁，也可以保证
 * 线程安全
 * 大量的线程进行并发的添加，减少
 */
public class AtomicIntegerArrayDemo {
    private static final AtomicIntegerArray atomicInteger = new AtomicIntegerArray(1000);

    static class Decrementer implements Runnable {
        AtomicIntegerArray atomicInteger;

        public Decrementer(AtomicIntegerArray atomicInteger) {
            this.atomicInteger = atomicInteger;
        }

        @Override
        public void run() {
            for (int ai = 0; ai < atomicInteger.length(); ai++) {
                atomicInteger.getAndIncrement(ai);
            }
        }
    }

    static class Incrementer implements Runnable {
        AtomicIntegerArray atomicInteger;

        public Incrementer(AtomicIntegerArray atomicInteger) {
            this.atomicInteger = atomicInteger;
        }

        @Override
        public void run() {
            for (int ai = 0; ai < atomicInteger.length(); ai++) {
                atomicInteger.getAndDecrement(ai);
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        int size = 100;
        Thread[] threadIns = new Thread[size];
        Thread[] threadDec = new Thread[size];
        for (int i = 0; i < size; i++) {
            threadIns[i] = new Thread(new Incrementer(atomicInteger));
            threadDec[i] = new Thread(new Decrementer(atomicInteger));
        }
        for (int i = 0; i < size; i++) {
            threadIns[i].start();
            threadDec[i].start();
        }
        for (int i = 0; i < size; i++) {
            threadIns[i].join();
            threadDec[i].join();
        }
        for (int i = 0; i < atomicInteger.length(); i++) {
            if (atomicInteger.get(i) != 0) {
                System.out.println("发现错误：位置" + i);
            }
        }
        System.out.println("程序运行结束");
    }
}
```

可以某个原子类型的操作

![image-20211021103337515](https://lhf-note.oss-cn-hangzhou.aliyuncs.com/img/202110211033642.png)





## 4.5 Atomic*Reference引用类型原子类

AtomicReference: AtomicReference类的作用，和AtomicInteger并没有本质区别，AtomicInteger可以让一个整数类型保证原子性，而AtomiceReference可以让一个**对象**保证原子性，当然，AtomicReference的功能明显比AtomicInteger更强，因为一个对象里可以**包含很多属性**,用法也和AtomicInteger类似。



模拟一个自旋锁实例

```java
/**
 * @author leihfei
 * @date 2021-10-21
 * 利用AtomicReference实现一个自旋锁
 */
public class AtomicReferenceDemo {
    private AtomicReference<Thread> sign = new AtomicReference<>();

    public void lock(){
        Thread thread = Thread.currentThread();
        while(!sign.compareAndSet(null, thread)){
//            System.out.println("自旋锁获取失败，继续尝试获取锁");
        }
    }

    public void unlock(){
        Thread thread = Thread.currentThread();
        // 当前线程是我持有锁，那么就进行释放锁
        sign.compareAndSet(thread, null);
    }

    public static void main(String[] args) {
        AtomicReferenceDemo lock = new AtomicReferenceDemo();
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName() + " 开始尝试获取自旋锁");
                lock.lock();
                System.out.println(Thread.currentThread().getName() + "获取自旋锁");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                lock.unlock();
            }
        };
        Thread t1 = new Thread(runnable);
        Thread t2 = new Thread(runnable);
        t1.start();
        t2.start();
    }
}

```

输出： 

Thread-1 开始尝试获取自旋锁
Thread-0 开始尝试获取自旋锁
Thread-1获取自旋锁

-----这里会大量输出自旋锁等待，继续尝试获取锁，CAS的原理体现

Thread-0获取自旋锁





##  4.6 把普通变量升级为原子类，用AtomicIntegerFiledUpdater升级原有变量

使用场景： **偶尔需要一个原子get-set操作**，大多数情况下是普通类型，不需要原子操作

如果一个类是自己编写的，则可以在编写的时候把成员变量实现成Atomic类型，但是如果是一个已有的类，在不能更改源码的情况下，要想实现对其成员变量的原子操作，就需要AtomicIntegerFieldUpdater, AtomicLongFieldUpdater 和 AtomicReferenceFieldUpdater.



例如：AtomicIntegerFieldUpdater类

要想使用AtomicIntegerFieldUpdater修改成员变量，成员变量必须是volatile的int类型，不能是包装类型Integer，因为该限制从构造函数就可以看出来

![image-20221030210056753](https://lhf-note.oss-cn-hangzhou.aliyuncs.com/imgAtomicIntegerFieldUpdater%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0.png)

其他的几个类型其实原理也是一样的。

代码示例如下所示：

```java
import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;

/**
 * @author leihfei
 * @date 2021-10-21
 * 对普通变量进行升级
 */
public class AtomicIntegerFieldUpdateDemo implements Runnable {

    static Candidate tom;
    static Candidate peter;

    public static AtomicIntegerFieldUpdater<Candidate> scoreUpdate = AtomicIntegerFieldUpdater.newUpdater(Candidate.class, "score");

    public static class Candidate {
        volatile int score;
    }

    @Override
    public void run() {
        for (int i = 0; i < 10000; i++) {
            peter.score++;
            scoreUpdate.getAndIncrement(tom);

        }
    }

    public static void main(String[] args) throws InterruptedException {
        tom = new Candidate();
        peter = new Candidate();
        AtomicIntegerFieldUpdateDemo d = new AtomicIntegerFieldUpdateDemo();
        Thread t1 = new Thread(d);
        Thread t2 = new Thread(d);
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        System.out.println("普通变量：" + peter.score);
        System.out.println("升级之后的：" + tom.score);
    }
}
```

结果： 

	普通变量：19898
	升级之后的：20000

**注意点： **

- 可见范围：原理是用到了反射，所以必须是public的变量
- 不支持被static修饰的变量，加了static会报错





## 4.7  Adder累加器

jdk8引入，相对比较新

针对Long型的原子操作，java提供了LongAdder,LongAccumulator,针对Double，又提供了DoubleAdder，DoubleAccumulator,Striped64相关的类的继承如下图所示：

![image-20221030201443734](https://lhf-note.oss-cn-hangzhou.aliyuncs.com/imgAdder%E7%B4%AF%E5%8A%A0%E5%99%A8%E7%B1%BB%E5%9B%BE.png)



高并发下LongAddr比AtomicLong效率高，不过本质是空间换时间

竞争激烈的时候，LongAddr把不同线程对应到不同的Cell上进行修改，降低了冲突发生的概率，是**多段锁** 的概念，提高了并发性。

**AtomicInteger由于竞争很激烈，每一次加法，都要flush和refresh，导致耗费资源**

演示两种代码的编写:

```java

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicLong;

/**
 * @author leihfei
 * @date 2021-10-21
 * 演示高并发场景下，LongAddr比AtomicLong性能好
 */
public class AtomicLongDemo {

    public static void main(String[] args) {
        long begin = System.currentTimeMillis();
        AtomicLong counter = new AtomicLong(0);
        ExecutorService service = Executors.newFixedThreadPool(20);
        for (int i = 0; i < 10000; i++) {
            service.submit(new Task(counter));
        }
        service.shutdown();
        while (!service.isTerminated()) {

        }
        System.out.println(counter.get());
        long end = System.currentTimeMillis();
        System.out.println("Atomic耗时" + (end - begin));

    }

    static class Task implements Runnable {
        private AtomicLong counter;

        public Task(AtomicLong counter) {
            this.counter = counter;
        }

        @Override
        public void run() {
            for (int i = 0; i < 10000; i++) {
                counter.incrementAndGet();
            }
        }
    }
}



import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.LongAdder;

/**
 * @author leihfei
 * @date 2021-10-21
 * 演示高并发场景下，LongAddr比AtomicLong性能好
 */
public class AddrLongDemo {

    public static void main(String[] args) {
        long begin = System.currentTimeMillis();
        LongAdder counter = new LongAdder();
        ExecutorService service = Executors.newFixedThreadPool(20);
        for (int i = 0; i < 10000; i++) {
            service.submit(new Task(counter));
        }
        service.shutdown();
        while (!service.isTerminated()) {

        }
        System.out.println(counter.sum());
        long end = System.currentTimeMillis();
        System.out.println("Adder耗时" + (end - begin));

    }

    static class Task implements Runnable {
        private LongAdder counter;

        public Task(LongAdder counter) {
            this.counter = counter;
        }

        @Override
        public void run() {
            for (int i = 0; i < 10000; i++) {
                counter.increment();
            }
        }
    }
}

```

**结果： **

**AtomicLong:**

100000000
Atomic耗时2025

**LongAdder:**

100000000
Adder耗时155

两种运行耗时是相差了量级的

原理：

**LongAdder的思路是把一个变量分解为多个变量，让同样多的线程去竞争多个资源**

LongAdder继承自Striped64，在Striped64中维护者三个变量：**base、cellsBusy、Cell数组**。base是个基础数据或初始数据，默认为0.cellsBusy用来实现自旋锁，状态值只有0和1，当创建Cell元素，扩容Cell数组或者初始化Cell数组时，使用CAS操作该变量来保证同时只有一个线程可以进行其中之一的操作。所以cells是volatile的，但没有加锁，而是用的自旋锁。

```java
/**
 * Table of cells. When non-null, size is a power of 2.
 */
transient volatile Cell[] cells;

/**
 * Base value, used mainly when there is no contention, but also as
 * a fallback during table initialization races. Updated via CAS.
 */
transient volatile long base;

/**
 * Spinlock (locked via CAS) used when resizing and/or creating Cells.
  主要是实现自旋锁，只有0/1
 */
transient volatile int cellsBusy;
```

每次调用increment时，都是调用add(1L)方法进行计算

![image-20211021211915298](https://lhf-note.oss-cn-hangzhou.aliyuncs.com/img/202110212120432.png)

然后调用父类的longAccumulate方法。



使用LongAdder时，内部维护了多个Cell变量，每个Cell里面有一个初始值为0的long型变量，这样同时争取一个变量的线程就变少了，而是分散成对多个变量的竞争，减少了失败次数。如果竞争某个Cell变量失败，它不会一直在这个Cell变量上自旋CAS重试，而是尝试在其他的Cell变量上进行CAS尝试，这个改变增加了当前线程重试CAS成功的可能性。最后，在获取LongAdder当前值时，是把所有Cell变量的value值累加后再加上base返回的。

LongAdder里面有一个Cell数组，是惰性加载的，即需要时创建。当并发线程较少时，所有累加操作都是针对base变量进行。Cell类型是AtomicLong的一个改进，用来减少缓存的争用，也就是解决伪共享问题（多线程想要共享变量，都是借助于主存）。因为Cell数组元素的内存地址是连续的，所以数组内的多个元素能经常共享缓存行，因此这里使用@sun.misc.Contended注解对Cell类进行字节填充，防止数组中多个元素共享一个缓存行，提升性能

**最核心代码：**

```java
final void longAccumulate(long x, LongBinaryOperator fn,
                              boolean wasUncontended) {
        int h;
        if ((h = getProbe()) == 0) { // 第一次进入，hash为0，必须进行初始化
            ThreadLocalRandom.current(); // force initialization
            // 设置hash值为
            h = getProbe();
            // 设置未竞争标记为true
            wasUncontended = true;
        }
        // 
        boolean collide = false;                // True if last slot nonempty
        for (;;) {
            Cell[] as; Cell a; int n; long v;
            if ((as = cells) != null && (n = as.length) > 0) { // cell为空或者数组非空，可以尝试累加
                if ((a = as[(n - 1) & h]) == null) { // 
                    if (cellsBusy == 0) {       // 尝试获取新的cell
                        Cell r = new Cell(x);   // 创建一个新的插槽
                        if (cellsBusy == 0 && casCellsBusy()) { // 尝试获取锁
                            boolean created = false;
                            try {               // Recheck under lock
                                Cell[] rs; int m, j;
                                if ((rs = cells) != null &&
                                    (m = rs.length) > 0 &&
                                    rs[j = (m - 1) & h] == null) {
                                    rs[j] = r;
                                    created = true;
                                }
                            } finally {
                                cellsBusy = 0;
                            }
                            if (created)
                                break;
                            continue;           // Slot is now non-empty
                        }
                    }
                    collide = false;
                }
                else if (!wasUncontended)       // CAS already known to fail
                    wasUncontended = true;      // Continue after rehash
                else if (a.cas(v = a.value, ((fn == null) ? v + x :
                                             fn.applyAsLong(v, x))))
                    break;
                else if (n >= NCPU || cells != as)
                    collide = false;            // At max size or stale
                else if (!collide)
                    collide = true;
                else if (cellsBusy == 0 && casCellsBusy()) {
                    try {
                        if (cells == as) {      // Expand table unless stale
                            Cell[] rs = new Cell[n << 1];
                            for (int i = 0; i < n; ++i)
                                rs[i] = as[i];
                            cells = rs;
                        }
                    } finally {
                        cellsBusy = 0;
                    }
                    collide = false;
                    continue;                   // Retry with expanded table
                }
                h = advanceProbe(h);
            }
            else if (cellsBusy == 0 && cells == as && casCellsBusy()) {
                boolean init = false;
                try {                           // Initialize table
                    if (cells == as) {
                        Cell[] rs = new Cell[2];
                        rs[h & 1] = new Cell(x);
                        cells = rs;
                        init = true;
                    }
                } finally {
                    cellsBusy = 0;
                }
                if (init)
                    break;
            }
            else if (casBase(v = base, ((fn == null) ? v + x :
                                        fn.applyAsLong(v, x))))
                break;                          // Fall back on using base
        }
    }
```



## 4.8 Accumulator累加器

accumulator累加器其实是LongAdder的升级版本，主要是改变了累加的功能，LongAdder只能固定每次累加1，而accumulator可以指定累加的业务逻辑，可以是相加，可以是相乘，取决于构造函数的第一个参数表达式**new LongAccumulator((x,y)->x * y,0);**



以下为实例代码：

```java

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.LongAccumulator;
import java.util.stream.IntStream;

/**
 * @author leihfei
 * @date 2021-10-21
 */
public class AccumulatorDemo {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newFixedThreadPool(20);
        LongAccumulator accumulator = new LongAccumulator((x,y)->x * y,0);
        IntStream.range(1,10).forEach((i)->executorService.submit(()->accumulator.accumulate(i)));
        executorService.shutdown();
        while(!executorService.isTerminated()){

        }
        System.out.println(accumulator.getThenReset());
    }
}
```

accumulator原理：

![image-20211021205031762](https://lhf-note.oss-cn-hangzhou.aliyuncs.com/img/202110212050006.png)

在Striped64类中，存在三个成员变量：**base、cellsBusy、Cell数组**，base:就是用来计算线程每次计算的值，分别是多个CPU核来保存或者是直接保存在base变量中



获取数据值的方法：

```java
public long getThenReset() {
    Cell[] as = cells; Cell a;
    // 其实base初始值也是在构造函数中赋值的，this.base=identity=构造函数传递的值
    long result = base;
    // identity 是传递的初始值，构造函数传递
    base = identity;
    if (as != null) {
    	// 判断cell插槽数据是否为空，不为空直接统计数据插槽中求和的数据
        for (int i = 0; i < as.length; ++i) {
            if ((a = as[i]) != null) {
                long v = a.value;
                a.value = identity;
                // 调用构造函数传递的计算函数，调用函数表达式进行数据生成
                result = function.applyAsLong(result, v);
            }
        }
    }
    return result;
}
```

累加器方法：

```java
/**
 * Updates with the given value.
 *
 * @param x the value
 */
public void accumulate(long x) {
    Cell[] as; long b, v, r; int m; Cell a;
    if ((as = cells) != null ||
        (r = function.applyAsLong(b = base, x)) != b && !casBase(b, r)) {
        boolean uncontended = true;
        if (as == null || (m = as.length - 1) < 0 ||
            (a = as[getProbe() & m]) == null ||
            !(uncontended =
              (r = function.applyAsLong(v = a.value, x)) == v ||
              a.cas(v, r)))
              // 调用父类总的longAccumulate方法，进行cpu的各种计算
            longAccumulate(x, function, uncontended);
    }
}
```



使用场景：

- 适合于需要大量计算，是需要并行计算
- 计算的顺序不能成为瓶颈，就是跟线程执行的顺序无关

注意点： 

- accumulator计算的值不一定是准确的，因为getThenReset()方法中，就是直接去获取一次cell中的累加值，也许还没有计算完毕







# 5. CAS

### 1. 什么是CAS

​	Compare And Set比较与交换

​	CAS有三个操作数：内存值V、预期值A、要修改的值B，**当且仅当预期值A和内存值V相同时，才能将内存值修改为B，否则什么也不做，最后返回现在的V值**



CAS主要是利用CPU的特殊指令来控制



### 2. CAS使用场景

		- 乐观锁
		- 并发容器，ConcurrentHashMap
		- 原子类 AtomicInteger 

​				a. 加载Unsafe类

​				b. volatile 修饰变量

​				c. compareAndSwapInt 处理





### 3.总结

​	缺点： 	

​		ABA问题:  可以利用版本号解决

​		自旋时间过长： CPU性能损耗过大

​		不能保证代码块的原子性，只能保证变量的原子性







# 6. final关键字和java中的不变性

​	final修饰的变量，都无法编译，无法修改

​	如果对象**在创建后，状态就不能被修改**，那么它就是不可变的。

​	例如：Person 类中有private final int age=18,那么该类就是不可变，但是如果还有另外一个public int score=0;这就破坏了不变性；

​	不可变的对象一定是线程安全的，我们不需要对其采用任何的额外安全措施，也能保证线程安全

**final的作用域： 类（防止被继承），方法（防止被重写），变量（防止被修改）**

赋值时机： 

​	类变量赋值private final int a;

​		 1. 直接赋值，2.{}代码块赋值，3.构造函数赋值

​	类变量static修饰变量赋值private static final int a;

​			1. 直接赋值，2.static{}静态代码块赋值

​	方法中的变量final int a;

​			只要求在使用前赋值



**构造方法不允许使用fianl修饰**

父类的static修饰的方法子类也不能添加overrride，但是可以在子类中写一个同样的方法，原因是： static静态的是在类初始化的时候就被创建了，这样产生的两个方法是属于两个类，子类和父类分别存在一个。

**final修饰对象的时候，只是对象的引用不可变，而对象本身的属性是可以变化的。**



不变性和final的关系：

- 不变性并不意味着，简单地使用final修饰就是不可变

- 对于基本数据类型，final修饰后就是具有不变性

- 对于对象类型，需要对该对象保证自身被创建后，状态永远不会变才可以（对象中所有属性都是不可变，且属性为基本数据类型）。
- 如果对象包含对象变量，但是变量不可能被更改，也是不可变的



**栈封闭技术： 栈是线程私有，方法内变量是栈内变量**



```java
/**
 * @author leihfei
 * @date 2021-11-12
 * 面试题
 */
public class Demo1 {
    public static void main(String[] args) {
        String a = "leisansui2"; // 常量池
        final String b = "leisansui"; // 直接不可变，放到常量池，直接就当成常量使用
        String d = "leisansui"; // 常量池
        String c = b + 2; // b是一个可以确定的常量，那么在编译时期就知道是什么，所以得到的值就是leisansui2,由于在常量中
        String e = d + 2; // d是常量池中的值，但是由于编译器在运行期间才知道d的值是什么，所以就会在堆上生成e的对象，那么e是一个引用
        // true
        System.out.println((a == c)); // c=b+2,得到的是一个字符串，那么就去常量池中查找，得到和a相同，那么就返回a的引用。所以相同
        // false
        System.out.println((a == e)); 
    }
}
解释： 
true
false
```

String相关知识点：

String在1.6时期，存在一个Pem区，并且和堆是两块独立区域，常量池在该区域。

String在1.7时期，取消Pem区，常量池移入堆区。

String在1.8时期，取消永久代，使用元数据Metaspace替代。

1. String a = "a"; 生成在常量池中，是一个常量，遇到这一句代码是，jvm会先去常量池寻找是否有a的值，有就直接a=“a"常量池地址的引用，没有就创建后放入常量池
2. String a = new String("a") 是生成在堆上
3. final String a  = "a"; 是一个常量，编译时期就知道是不可变



# 7. ConcurrentHashMap等并发集合

## 7.1 概览

ConcurrentHashMap:线程安全的HashMap

CopyOnWriteArrayList: 线程安全的List

BlockingQueue: 这是一个接口，表示阻塞队列，非常适合用于做为数据共享的通道

ConcurrentLinkedQueue: 高效的非阻塞并发队列，可以看到做是一个线程安全的LinkedList

ConcurrentSkipListMap: 是一个Map，实用跳表的数据结构进行快速查找



## 7.2 集合类的历史

- Vector和Hashtable

  Vector可以作为ArrayList,方法全部由synchronized方法修饰

  Hashtable当做普通的HashMap,方法全部由synchronized方法修饰

  **并发性能差，但是线程安全**

  

- ArrayList和HashMap

  **线程不安全**，可以使用```Collections.synchronizedList(new ArrayList<E>())```和```Collections.synchronizedMap(new HashMap<K,V>())```包装之后变成线程安全的。包装类保证线程安全的原理： 是使用了**synchronized**的同步代码块来保证线程安全

  

- ConcurrentHashMap和CopyOnWriteArrayList

  主要是取代ArrayList和HashMap的线程不安全

  绝大多数的并发情况下，ConcurrentHashMap和CopyOnWriteArrayList的性能要更好



## 7.3 Map接口

实现： HashMap,Hashtable, LinkedHashMap,TreeMap

<img src="https://lhf-note.oss-cn-hangzhou.aliyuncs.com/img/image-20211112141253089.png" alt="image-20211112141253089" style="zoom: 200%;" />



- HashMap

  使用hash作为key，提供快速访问值，key可以为null,值不限制,线程不安全

  

- Hashtable

​		**线程安全**,key不允许为空



- LinkedHashMap

​		**线程不安全**，key允许为null



- TreeMap

  实现了Sort接口，可以得到排序，**线程不安全**,key不允许为null

  ![image-20211112142346743](https://lhf-note.oss-cn-hangzhou.aliyuncs.com/img/image-20211112142346743.png)



## 7.4 HashMap的死循环，CPU100%问题

原因： 多个线程同时扩容，导致链表互相指向，导致出现环形链表，进而出现死循环

[ 原理文章](https://coolshell.cn/articles/9606.html)



## 7.5 HashMap特点

红黑树：R-B Tree，全称是Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。

**红黑树的特性**:
**（1）每个节点或者是黑色，或者是红色。**
**（2）根节点是黑色。**
**（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]**
**（4）如果一个节点是红色的，则它的子节点必须是黑色的。**
  **(5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。**



**特点**

1. 非线程安全
2. 迭代时不允许修改内容
3. 只读是并发安全的
4. 如果一定要把HashMap在并发环境，那么使用Collections.synchronizedMap(new Hash())来包装



## 7.6 ConcurrentHashMap在Java7/8版本的区别

Java 7：

- 中的ConcurrentHashMap最外层是多个segment,每个segment的底层数据结构与HashMap类似，仍然使用数组和链表组成的拉链法

- 每个Segment独立上ReentrantLock锁，每个segment之间互不影响，提高并发效率

- ConcurrentHashMap默认有16个segment，所以最多支持16线程并发写（操作分布在不同的segment上）。这个默认值可以在初始化的时候设置为其他值，但是后续不能更改扩容。

  

![image-20211112152344788](https://lhf-note.oss-cn-hangzhou.aliyuncs.com/img/image-20211112152344788.png)



Java 8：

- 存储结构完全跟HashMap相同，利用红黑树，链表等数据结构，每一个Node都是独立的

- 完全重写了ConcurrentHashMap整个代码，主要底层使用同步代码块synchronized+CAS

- key或value为null，直接会抛出异常

![image-20211112152232816](https://lhf-note.oss-cn-hangzhou.aliyuncs.com/img/image-20211112152232816.png)

put方法，putVal方法大致流程

- 判断key,value是否为空，为空抛出异常
- 计算key的hash值
- 根据对应的节点类型进行赋值，或者进行helpTransfer,或者增长链表，或者给红黑树增加节点
- 检查是否满足阈值8，需要进行链表转红黑树，且在转换前还要判断数组长度必须大于64
- 返回原始旧值oldVal

```java
/** Implementation for put and putIfAbsent */
final V putVal(K key, V value, boolean onlyIfAbsent) {
	// 处理key,value是否为空
    if (key == null || value == null) throw new NullPointerException();
    // 计算hash值
    int hash = spread(key.hashCode());
    int binCount = 0;
    // 循环存储的数据节点
    for (Node<K,V>[] tab = table;;) {
        Node<K,V> f; int n, i, fh;
        // 判断数组是否为空，为空需要进行初始化
        if (tab == null || (n = tab.length) == 0)
        	// 初始化数据数组
            tab = initTable();
        else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {
        	// 判断数组中的该hash出来的位置是否为空，为空直接进行数据的cas插入
            if (casTabAt(tab, i, null,
                         new Node<K,V>(hash, key, value, null)))
                break;                   // no lock when adding to empty bin
        }
        // 不为空，判断该节点是否为一个MOVED节点类型，hash for forwarding nodes转移节点
        // MOVED=-1,就是计算hash的时候，如果hash值为-1，就说明该位置正在进行扩容等相关操作
        else if ((fh = f.hash) == MOVED)
        	// 帮助进行 扩容
            tab = helpTransfer(tab, f);
        else {
            V oldVal = null;
            // 进行同步代码块锁定，f为当前节点的值
            synchronized (f) {
            	// 判断是否为链表节点
                if (tabAt(tab, i) == f) {
                	// 判断hash值大于0
                    if (fh >= 0) {
                        binCount = 1;
                        // 循环链表进行追加数据
                        for (Node<K,V> e = f;; ++binCount) {
                            K ek;
                            // hash相同，value也相同，直接覆盖原来的数据
                            if (e.hash == hash &&
                                ((ek = e.key) == key ||
                                 (ek != null && key.equals(ek)))) {
                                oldVal = e.val;
                                if (!onlyIfAbsent)
                                    e.val = value;
                                break;
                            }
                            Node<K,V> pred = e;
                            // 追加在最后面
                            if ((e = e.next) == null) {
                                pred.next = new Node<K,V>(hash, key,
                                                          value, null);
                                break;
                            }
                        }
                    }
                    // 判断是否为红黑树
                    else if (f instanceof TreeBin) {
                        Node<K,V> p;
                        binCount = 2;
                        // 进行树节点插入
                        if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,
                                                       value)) != null) {
                            oldVal = p.val;
                            if (!onlyIfAbsent)
                                p.val = value;
                        }
                    }
                }
            }
            // 判断是否发生了节点变化的操作，链表的binCount会支持增加，红黑树只能为2
            if (binCount != 0) {
            	// 判断是否触发链表转换红黑树，阈值8
                if (binCount >= TREEIFY_THRESHOLD)
                	// 转换红黑树
                    treeifyBin(tab, i);
                if (oldVal != null)
                	// 返回旧值
                    return oldVal;
                break;
            }
        }
    }
    // 统计目前数组的长度
    addCount(1L, binCount);
    return null;
}
```

get方法，大致流程

- 计算key的hash值
- 找到对应的位置，根据情况进行：
  1. 直接取值
  2. 红黑树中寻找
  3. 遍历链表取值
  4. 返回寻找的结果

```java
public V get(Object key) {
    Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek;
    // 计算hash值
    int h = spread(key.hashCode());
    // 判断数组是否存在数据，并且获取出节点值不为null
    if ((tab = table) != null && (n = tab.length) > 0 &&
        (e = tabAt(tab, (n - 1) & h)) != null) {
        // 判断节点获取的值的的hash值是否相等
        if ((eh = e.hash) == h) {
        	// 判断原始key是否相等，相等就返回存储的value值
            if ((ek = e.key) == key || (ek != null && key.equals(ek)))
                return e.val;
        }
        // 获取到的hash<0
        else if (eh < 0)
        	// 从红黑树中寻找节点
            return (p = e.find(h, key)) != null ? p.val : null;
        // 从链表中循环取出数据
        while ((e = e.next) != null) {
            if (e.hash == h &&
                ((ek = e.key) == key || (ek != null && key.equals(ek))))
                return e.val;
        }
    }
    return null;
}
```



Java8、7区别：

- 数据结构区别

  7： segment结构，segment独立，8：链表+红黑树，每个Node单独

- Hash碰撞

  7： 直接使用拉链法，8：先使用拉链法，后使用红黑树

- 保证并发安全

  7： 使用segment继承ReentrantLock，8： sychronized代码块+cas

- 查询复杂度

  7： O(n), 8: O(logn)



为什么链表长度8就要转换为红黑树？

答： 数据量不多的时候，不需要转换，红黑树占用空间比链表更大，想要达到链表长度为8的概率都比较小，概率为千万级别，所以选择8是一个概率值。

​		不过理想情况下随机hashCode算法下所有bin中节点的分布频率会遵循**泊松分布**，我们可以看到，一个bin中链表长度达到8个元素的概率为0.00000006，几乎是不可能事件。



## 7.7 组合操作不保证线程安全

其实ConcurrentHashMap保证的是已经存在了的数据是线程安全，比如：get,put动作是线程安全的，但是组合操作：get,然后操作数据，put，那么这三个动作不是线程安全的。

保证安全： 

 1. 组合操作代码添加同步代码块

 2. 使用replace方法，多次检查是否是可以修改

    ```
    while(true){
    	boolean b = hashMap.replace(key,oldValue,newValue);
    	if(b){
    		break;
    	}
    }
    ```



putIfAbsent方法：

​	对key进行赋值，如果有key存在值，那么返回值，不存在key，返回null,可以避免使用

```
if(!map.contains(key)){
	// 获取值
}else {
	// 存在key,进行修改值
}
```

​	**该方法直接调用的是putVal方法，但是第三个参数onlyIfAbsent为true,该参数控制putVal的值是否需要被修改，true=返回key得到的值，false=返回key得到的值，并且对key修改值。**



## 7.8 CopyOnWriteArrayList

Vector和SychronizedList的锁粒度太大，并发效率相对较低，并且迭代时无法编辑

Copy-On-Write并发容易还包括CopyOnWriteArraySet用来替代Set集合



CopyOnWriteArrayList使用场景：

- 读操作尽可能快，而写操作慢一些都没有关系
- 读多写少： 黑名单，每日更新；监听器：迭代操作远多于修改操作



**读写锁规则：读读共享，其他都互斥**



CopyOnWrite的读写规则：

**读取是完全不需要加锁，并且更厉害的是，写入也不会阻塞其他操作。只有线程都是写写才会进行互斥。**



CopyOnWrite的含义：

​	复制-写入

是一种程序设计中的优化策略，其实现思路是大家都在共享一个内容，当有人想要修改内容的时候，就创建一个改内容的副本，对副本进行修改，然后再将原本的引用指向副本，完成内容的修改。是一种读写分离的并发策略，也是一种延时惰性策略



**缺点：**

- 数据一致性：CopyOnWrite容器只能保证最终一致性，无法保证实时一致性
- 内存占用问题： 因为CopyOnWrite的写是复制机制，每次写都上锁，并且复制一份数据拷贝，内存中会同时存在两个对象



**数据结构：**

​	ReentrantLock是锁

​	存储是Object[] 数组



**add方法源码：**

```java
/**
 * Appends the specified element to the end of this list.
 *
 * @param e element to be appended to this list
 * @return {@code true} (as specified by {@link Collection#add})
 */
public boolean add(E e) {
	// 获取锁
    final ReentrantLock lock = this.lock;
    // 进行枷锁
    lock.lock();
    try {
    	// 得到当前的数组的引用
        Object[] elements = getArray();
        int len = elements.length;
        // 调用系统方法进行拷贝，并且长度+1
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        // 对最后一个位置进行复制
        newElements[len] = e;
        // 然后重新进行引用设置
        setArray(newElements);
        return true;
    } finally {
    	// 释放锁
        lock.unlock();
    }
}
```



## 7.9 并发队列Queue：阻塞队列

Queue接口： 

- LinkedBlockingQueue
- ArrayListBlockingQueue
- PriorityBlockingQueue
- SynchronousQueue

![image-20211112163918406](https://lhf-note.oss-cn-hangzhou.aliyuncs.com/img/image-20211112163918406.png)

​	什么是阻塞队列？

​		阻塞队列具有阻塞功能的队列

​		阻塞队列是否有界：这是一个非常重要的属性，无界队列意味着容量为Integer.MAX_VALUE。



###  ArrayBlockingQueue

1. 有界,构造是必须传递一个长度

2. 是否公平

   如果想要保证公平的话，那么等待了最长时间的线程会被优先处理，不过这同时会带来性能上的损耗



### LinkedBlockingQueue

使用链表作为数据结构

- 无界队列

- 容量为Integer.MAX_VALUE

- 内部结构： Node节点，并且存在两把同步锁

  ![image-20211112170819536](https://lhf-note.oss-cn-hangzhou.aliyuncs.com/img/image-20211112170819536.png)



分析put方法：

```java
/**
 * Inserts the specified element at the tail of this queue, waiting if
 * necessary for space to become available.
 *
 * @throws InterruptedException {@inheritDoc}
 * @throws NullPointerException {@inheritDoc}
 */
public void put(E e) throws InterruptedException {
	// 元素不允许为空
    if (e == null) throw new NullPointerException();
    // Note: convention in all put/take/etc is to preset local var
    // holding count negative to indicate failure unless set.
    int c = -1;
    Node<E> node = new Node<E>(e);
    // 获取插入锁
    final ReentrantLock putLock = this.putLock;
    // 利用原子类AtomicInteger来保证长度修改是线程安全
    final AtomicInteger count = this.count;
    // 获取可以响应中断的锁
    putLock.lockInterruptibly();
    try {
        /*
         * Note that count is used in wait guard even though it is
         * not protected by lock. This works because count can
         * only decrease at this point (all other puts are shut
         * out by lock), and we (or some other waiting put) are
         * signalled if it ever changes from capacity. Similarly
         * for all other uses of count in other wait guards.
         */
         // 如果长度到了，那么就进行等待
        while (count.get() == capacity) {
            notFull.await();
        }
        // 放入队列
        enqueue(node);
        // 队列中的元素+1
        c = count.getAndIncrement();
        // 如果元素小于初始容量，那么进行通知唤醒休眠线程
        if (c + 1 < capacity)
            notFull.signal();
    } finally {
    // 解锁
        putLock.unlock();
    }
    if (c == 0)
        signalNotEmpty();
}
```



### PriorityBlockingQueue

具有排序的队列，支持优先级，并且是自然排序（不是先进先出），是一个无界队列，插入的东西必须是可以比较的



### SynchronousQueue

容量为0

特别注意的是： SynchronousQueue的容量不是1而是0，因为SynchronousQueue不需要持有元素，它所做的就是直接传递（direct handoff）

由于不存储，效率较高



注意：

SynchronousQueue没有peek等函数，

是一个直接交换的并发数据结构

SynchronousQueue是线程池Executors.newCachedThreadPool()的工作队列



### DelayQueue

延时队列，根据排序时间排序

元素必须实现Delayed接口，规定排序规则

是一个无界队列



### 非阻塞并发队列：ConcurrentLinkedQueue

ConcurrentLinkedQueue: 是使用链表作为数据结构，并且是CAS非阻塞算法来实现线程安全（不具备阻塞功能），适合用在对性能要求较高的并发场景。

offer方法：

```java
/**
 * Inserts the specified element at the tail of this queue.
 * As the queue is unbounded, this method will never return {@code false}.
 *
 * @return {@code true} (as specified by {@link Queue#offer})
 * @throws NullPointerException if the specified element is null
 */
public boolean offer(E e) {
    checkNotNull(e);
    final Node<E> newNode = new Node<E>(e);

    for (Node<E> t = tail, p = t;;) {
        Node<E> q = p.next;
        if (q == null) {
            // p is last node 使用了CAS来保证线程安全
            if (p.casNext(null, newNode)) {
                // Successful CAS is the linearization point
                // for e to become an element of this queue,
                // and for newNode to become "live".
                if (p != t) // hop two nodes at a time
                    casTail(t, newNode);  // Failure is OK.
                return true;
            }
            // Lost CAS race to another thread; re-read next
        }
        else if (p == q)
            // We have fallen off list.  If tail is unchanged, it
            // will also be off-list, in which case we need to
            // jump to head, from which all live nodes are always
            // reachable.  Else the new tail is a better bet.
            p = (t != (t = tail)) ? t : head;
        else
            // Check for tail updates after two hops.
            p = (p != t && t != (t = tail)) ? t : q;
    }
}
```



如何选择使用自己的队列？

- 边界
- 控件
- 吞吐量





### **总结**

java.util.concurrent包提供的容器，分为3类：

- Concurrent*

  通过CAS实现并发

  

- CopyOnWrite*

  通过复制一份数据实现

  ReentrantLock实现锁

  

- Blocking*

​		通过会用ReentrantLock实现，也就是AQS





# 8. 控制并发流程

控制并发流程的工具类，作用就是帮我我们更容易让线程之间合作，让线程相互配合，来满足业务需求



| 类             | 作用                                                         | 说明                                                         |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Semaphore      | 信号量，可以通过制作“许可证”的数量，来保证线程之间的配合     | 线程只有拿到了“许可证”后才能继续运行，相比于其他的同步器更加灵活 |
| CyclicBarrier  | 线程会等待，直到足够多的线程达到了事先规定的数目，一旦达到触发条件就可以进行下一步动作 | 适用于线程之间相互等待处理结果就绪的场景                     |
| Phaser         | 和CyclicBarrier类似，但是计数是可变的                        | Java7才加入的                                                |
| CountDownLatch | 和CyclicBarrier类似，计数器递减到0时，才触发动作             | 不可重复使用                                                 |
| Exchanger      | 让两个所线程在合适时交换对象                                 | 使用场景： 当两个线程在同一个类的不同实例上时，用于交换数据  |
| Condition      | 可以控制线程的“等待”和“唤醒”                                 | 是Object.wait()的升级版                                      |



## 8.1 CountDownLatch 倒计时门栓

自顶向下的CountDoanLatch，类似于一个门栓：“倒数门栓”

作用： 控制并发流程

例子： 购物拼团；大巴车，都是等待xx，然后干什么

流程：开始--->进入等待--->倒数结束--->继续工作



**方法解释说明**

CountDownLatch(int count)：只有一个构造函数，参数count为需要倒数的数值

await(): 调用wait()方法的线程会被挂起，他会等待直到count的值为0才继续执行

countDown(): 将count的值减1，直到为0，等待的线程会被唤起



**作用示意图：**

![image-20211115112226882](https://lhf-note.oss-cn-hangzhou.aliyuncs.com/img/image-20211115112226882.png)



**用法一**: 一个线程等待多个线程都执行完毕，再继续自己的工作。

```java
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * @author leihfei
 * @date 2021-11-15
 * 工厂中，质检，5个工人检查，所有人都人为通过之后，工件才能进入下一个环节
 */
public class CountDownDemo1 {

    public static void main(String[] args) throws InterruptedException {
        CountDownLatch countDownLatch = new CountDownLatch(5);
        ExecutorService service = Executors.newFixedThreadPool(5);
        for (int i = 0; i < 5; i++) {
            int finalI = i;
           Runnable runnable =  new Runnable() {
                @Override
                public void run() {
                    try {
                        Thread.sleep((long) Math.random() * 10000);
                        System.out.println("No." + (finalI + 1) + " 完成了检查");
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }finally {
                    	// 进行检查工作，让数量-1，一直减到0时，就进入resume，继续执行主线程
                        countDownLatch.countDown();
                    }
                }
            };
            service.submit(runnable);
        }
        System.out.println("等待5个人检查完......");
        countDownLatch.await();
        System.out.println("所有人都完成了工作，进入下一个环节");
        service.shutdown();
    }
}
```

只有当5个质检数据都完毕之后，主线程才会继续执行





**用法二**：多个运动员在起跑线上，统一的等待发令员进行发令起跑

```java
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * @author leihfei
 * @date 2021-11-15
 * 模拟100米跑步，运动员都准备好，等待指令员发指令
 */
public class CountDownDemo2 {

    public static void main(String[] args) throws InterruptedException {

        CountDownLatch countDownLatch = new CountDownLatch(1);
        ExecutorService executorService = Executors.newFixedThreadPool(5);
        for (int i = 0; i < 5; i++) {
            final int no = i+1;
            Runnable runnable = new Runnable(){
                @Override
                public void run() {
                    System.out.println("No." + no + "准备完毕，等待发令枪");
                    try {
                        countDownLatch.await();
                        System.out.println("NO." + no + " 开始跑步了");
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            };
            executorService.submit(runnable);
        }
        // 裁判员进行检查，准备发令
        Thread.sleep(5000);
        System.out.println("发令枪响，比赛开始");
        // 进行发令
        countDownLatch.countDown();
        executorService.shutdown();
    }
}
```

当主线程将count设置为0的时候，线程池中的线程会同时执行

**注意:线程池的选择需要同时可以放入这么多个远动员，而不能进入阻塞队列，否则的话执行会有问题，有会排队现象**



扩展：

模拟100米跑步，运动员都准备好，等待指令员发指令终点需要等待5个远动员等到到了终点，然后统一结束

```java
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * @author leihfei
 * @date 2021-11-15
 * 模拟100米跑步，运动员都准备好，等待指令员发指令
 * 终点需要等待5个远动员等到到了终点，然后统一结束
 */
public class CountDownDemo2_1 {
    public static void main(String[] args) throws InterruptedException {

        CountDownLatch begin = new CountDownLatch(1);
        CountDownLatch end = new CountDownLatch(5);
        ExecutorService executorService = Executors.newFixedThreadPool(5);
        for (int i = 0; i < 5; i++) {
            final int no = i + 1;
            Runnable runnable = new Runnable() {
                @Override
                public void run() {
                    System.out.println("No." + no + "准备完毕，等待发令枪");
                    try {
                        begin.await();
                        System.out.println("NO." + no + " 开始跑步了");
                        Thread.sleep((long) (Math.random() * 10000));
                        System.out.println("No." + no + " 到终点了");
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    } finally {
                        end.countDown();
                    }
                }
            };
            executorService.submit(runnable);
        }
        // 裁判员进行检查，准备发令
        Thread.sleep(5000);
        System.out.println("发令枪响，比赛开始");
        // 进行发令
        begin.countDown();
        end.await();
        System.out.println("5位运动员都到达了终点");
        executorService.shutdown();
    }
}
```

**注意点： CountDownLatch是不能重用的，如果需要重新计数，可以考虑使用CycliBarrier或者创建新的CountDownLatch实例。**

只要是await通过之后，再次调用都是直接就放过了，是基本没有反应



**总结**： 经典用法，一等多、多等一

CountDownLatch类在创建实例的时候，需要传递倒数次数。倒数到0的时候，之前等待的线程会继续运行

CountDownLathc是不能回滚重置的





## 8.2 Semaphore 信号量

其实就是模拟了操作系统的信号量： **主要用来限制或管理数量有限的资源的使用情况**



信号量的作用是维护一个**许可证**的计数，线程可以**”获取许可证“**，那信号量的剩余许可证就减1，线程也可以**”释放“**一个许可证，那么信号量剩余的许可证就加1，当信号量的许可证数量为0，那么下一个线程想要获取许可证的线程，就需要等待，直到有另外的线程释放了许可证.



**Semaphore信号量原理**

![image-20211115144237037](https://lhf-note.oss-cn-hangzhou.aliyuncs.com/img/image-20211115144237037.png)



信号量使用流程

1. 初始化Semaphore并指定许可证数量
2. 在需要被现在的代码前加acquire()或者acquireUninterruptibly()方法
3. 在任务执行结束，调用release()来释放



new Semaphore(int permits,boolean fair): 这里可以设置是否需要使用**公平**策略，如果传入true，那么Semaphore会把之前等待的线程加入FIFO的队列里，以便于当有了新的许可证，可以分发给之前等了最长时间的线程。false： 就可以插队



acquire(): 获取一个许可证，就进行阻塞

tryAcquire()： 获取一个许可证，没有就直接返回

acquireUninterruptibly()： 获取一个许可证，但是可以响应中断

tryAcquire(timeout):  获取一个许可证，在等待时间获取不到就返回

release()： 归还许可证



**特殊用法**：

​	acquire(int permits): 是可以传递一个许可证的个数，如果一次性传递多个，那么释放也一定要注意释放多个

​	release(int permits): 一次性释放多个许可证



**注意点**：

​	获取和释放的数量最好要一致，否则许可证会越来越少，直到线程卡死，因为许可证会越来越少。

​	注意在初始化Semaphore的时候设置**公平性**，一般为true会更合理

​	获取和释放许可证对线程是没有要求的，谁释放都可以

​	信号量的作用，除了控制临界区最多同时又N个线程访问外，另一个作用是可以实现**条件等待**，例如线程1需要在线程2完成准备工作之后在开始工作，那么就线程1进行acquire(),而线程而完成任务之后release(),这样的话，相当于实现了一个轻量级的CountDownLatch





​	

## 8.3 Condition接口，又称为条件对象

condition作用： 线程1需要等待某个条件的时候，它就去执行condition.await方法，一旦执行了await方法，线程就会进入阻塞状态。另外的线程需要去执行condition.signal()方法，这时JVM就会从被阻塞的线程里找，找到那些等待condition条件的线程，当线程收到了可执行号的时候，那么线程1就会退出阻塞状态，进入Runnable状态。

如下图所示：

![image-20211115151130341](https://lhf-note.oss-cn-hangzhou.aliyuncs.com/img/image-20211115151130341.png)



signalAll方法会换气所有正在等在的线程

singal()是公平的，只会唤醒等待时间最长的线程



示例代码：

```java
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @author leihfei
 * @date 2021-11-15
 * 演示Condition的基本用法
 * 特点是绑定在锁上面的，ReentrantLock
 */
public class ConditionDemo1 {
    private ReentrantLock lock = new ReentrantLock();
	// 创建一个条件对象
    private Condition condition = lock.newCondition();


    void meth1(){
        lock.lock();
        try{
            System.out.println("线程1条件不满足，开始await进入阻塞");
            condition.await();
            System.out.println("线程1条件满足了，开始执行后续任务");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }

    }

    void meth2(){
        lock.lock();
        try{
            System.out.println("线程2，准备工作完成，唤醒其他线程");
            condition.signal();
        }finally {
            lock.unlock();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        ConditionDemo1 demo1 = new ConditionDemo1();
        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("线程1进行调用条件，判断是否满足");
                demo1.meth1();
            }
        }).start();
        Thread.sleep(1000);
        new Thread(new Runnable() {
            @Override
            public void run() {
                demo1.meth2();
            }
        }).start();

    }
}
```



生产者消费者模式：

```java
import java.util.PriorityQueue;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @author leihfei
 * @date 2021-11-15
 * 演示 使用Condition模拟生产者消费者
 */
public class ConditionDemo2 {
    private int queueSize = 10;
    private PriorityQueue<Integer> queue = new PriorityQueue<>(queueSize);

    private Lock lock = new ReentrantLock();
    // 队列没有满
    private Condition notFull = lock.newCondition();
    // 队列没有空
    private Condition notEmpty = lock.newCondition();

    class Consumer extends Thread {
        @Override
        public void run() {
            consume();
        }

        private void consume() {
            while (true) {
                lock.lock();
                try {
                    while (queue.size() == 0) {
                        System.out.println("队列为空，等待生产者数据");
                        try {
                            notEmpty.await();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                    // 队列有数据，那么就拿出数据
                    queue.poll();
                    notFull.signalAll();
                    System.out.println("从队列里取走了数据，队列还剩余:" + queue.size() + " 个元素");
                } finally {
                    lock.unlock();
                }
            }
        }
    }

    class Producer extends Thread {
        @Override
        public void run() {
            produce();
        }

        private void produce() {
            while (true) {
                lock.lock();
                try {
                    while (queue.size() == queueSize) {
                        System.out.println("队列已经满了，通知消费者消费");
                        try {
                            notFull.await();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                    // 队列有数据，那么就拿出数据
                    queue.offer(1);
                    notEmpty.signalAll();
                    Thread.sleep(200);
                    System.out.println("向队列插入了一个元素，还剩余：" + ( queue.size()) +" 个元素");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    lock.unlock();
                }
            }
        }
    }

    public static void main(String[] args) {
        ConditionDemo2 demo = new ConditionDemo2();
        Consumer consumer = demo.new Consumer();
        Producer producer = demo.new Producer();
        consumer.start();
        producer.start();
    }
}
```

注意点：

1. 实际上，如果说Lock用来替代synchronized，那么Condition就是用来替代Object.wait/notify的，所以在用法和性质上，几乎一样
2. await方法会自动释放持有的Lock锁，和Object.wait一样，不需要自己手动释放锁
3. 调用await的时候，也必须持有锁，否则要抛出异常，和Object.wait一样



优点： 主要是可以绑定多个锁对象



## 8.4 CyclicBarrier 循环栅栏

CyclicBarrier循环栅栏和CountDownLatch很类似，都能阻塞一组线程

当有大量的线程相互配合，分别计算不同的任务，并且最后都要统一**汇总**，我们可以使用CyclicBarrier，CyclicBarrier可以构建一个集结点，直到所有的线程都到了集结点，那么该栅栏就会被撤销，所有的线程再统一出发，继续执行剩下的任务。



演示代码：

```java
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;

/**
 * @author leihfei
 * @date 2021-11-15
 * 演示CyclicBarrier,课重用，比如说：5个人到了，就会继续执行任务，下5个又到了，还会继续执行任务
 * 
 */
public class CyclicbarrierDemo {
    public static void main(String[] args) {
        CyclicBarrier cyclicBarrier = new CyclicBarrier(5, new Runnable() {
            @Override
            public void run() {
                // 这里就是线程统一到达了之后，想要干什么
                System.out.println("所有线程到场，开始执行统一任务");
            }
        });

        for (int i = 0; i < 10; i++) {
            Task task = new Task(i, cyclicBarrier);
            Thread thread = new Thread(task);
            thread.start();
        }
    }

    static class Task implements Runnable{
        private int id;
        private CyclicBarrier cyclicBarrier;
        public Task(int _id){
            this.id = _id;
        }

        public Task(int _id,CyclicBarrier cy){
            this.id = _id;
            this.cyclicBarrier = cy;
        }

        @Override
        public void run() {
            System.out.println("线程" + id+ "开始出发");
            try {
                Thread.sleep((long) (Math.random() * 10000));
                System.out.println("线程" + id +" 到达了集结点");
                try {
                    cyclicBarrier.await();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```



CyclicBarrier和CountDownLatch的区别

- 作用不同： CyclicBarrier要等固定数量的线程到达了栅栏位置才能继续执行，而CountDownLatch只需要等count的数量为0，也就是说，CountDownLatch作用于事件，而CyclicBarrier作用于线程。
- 可重用行不同：CountDownLatch在倒数为0就触发闸门打开后，就不能再次使用了，除非新建新的实例，而CyclicBarrier可以重复使用。





# 9. AQS

AQS:  AbstractQueuedSynchronizer

AQS是一个用于构建锁，同步器、协同同居类的工具类（框架），有了AQS,更多的协同工具类都可以很方便的被写出来。

**AbstractQueuedSynchronizer是从JDK1.5加入的一个给予FIFO等待队列实现的一个用于实现同步器的基础框架。**



![image-20211115162653752](https://lhf-note.oss-cn-hangzhou.aliyuncs.com/img/image-20211115162653752.png)

如果没有AQS，就需要每个协同工具自己实现：

- 同步状态的原子性管理
- 线程的阻塞与解除阻塞
- 队列的管理



AQS的最核心的三大部分：

**state状态**

会根据不同的是实现类的不同而不同，比如在Semaphore中，state表示**剩余许可证的数量**，在CountDownLatch中，表示**剩余的倒数的数量**

state是volatile修饰的，会被并发的修改，所有的修改都需要保证**线程安全**，比如getState,setState、compareAndSetState操作来读取和更新这个状态，这些方法都依赖于j.u.c.atomic包的支持。

在ReentrantLock中，state表示**锁**的占用情况，包括**可重入计数**，当state为0的时候，表示Lock不被任何线程占有，表示锁是释放状态



**控制线程枪锁和配合的FIFO队列**

​	这个队列用来存放**等待的线程**，Aqs就是“排队管理器”，当多个线程同时争用一把锁时，必须有排队机制将那些没有获取到锁的线程串在一起，当锁释放时，排队管理器会挑选一个合适的线程来占有这个刚刚释放的锁。

​	AQS会维护一个等待的线程队列，把**线程都放到这个队列中**

​	队列使用的是一个双向列表

![image-20211115163903630](https://lhf-note.oss-cn-hangzhou.aliyuncs.com/img/image-20211115163903630.png)

源代码如下图所示：





![image-20211115163835979](https://lhf-note.oss-cn-hangzhou.aliyuncs.com/img/image-20211115163835979.png)



**期望协同工具类去实现的获取/释放等重要方法**

​		这里的获取和释放方法，是利用AQS的协作工具类里最重要的方法，是由协作类自己去实现，而且含义各不相同。

​	**获取方法：**

​			 获取方法依赖于state变量，经常会阻塞（比如获取不到锁的时候）	

​			在Reentrant中，获取方法lock，作用就是重入次数，就是state+1

​			在Semaphore中，获取就是acquire方法，作用就是获取一个许可证

​			在CountDownLatch里面，获取就是await方法，作用就是**等待，直到倒数结束**

​	 **释放方法：**

​			在Reentrant中，释放方式就是unlock，作用就是释放锁，有重入就-1，没重入就释放

​			在Semaphore中，释放就是release，作用就是释放一个许可证

​			在CountDownLatch中，释放就是countDown，作用就是count减1

​	

源码分析：







动手实现一个门栓

```java
import java.util.concurrent.locks.AbstractQueuedSynchronizer;

/**
 * @author leihfei
 * @date 2021-11-15
 * 模拟一个一次性门栓，当只要调用了一次countDown，就所有线程都放过
 */
public class OneShotLatch {
    private final Syncs sync = new Syncs();

    /**
     * 固定套路
     */
    public void await() {
        sync.acquireShared(0);
    }

    /**
     * 固定套路
     */
    public void signal() {
        sync.releaseShared(0);
    }


    /**
     * 相当于固定模板，根据独占锁和共享锁
     */
    private class Syncs extends AbstractQueuedSynchronizer {

        /**
         * 自己控制的，什么时候加入到排队阻塞队列
         * @param arg
         * @return
         */
        @Override
        protected int tryAcquireShared(int arg) {
            return (getState() == 1) ? 1 : -1;
        }

        /**
         * 判断是否唤醒线程
         * @param arg
         * @return
         */
        @Override
        protected boolean tryReleaseShared(int arg) {
            setState(1);
            return true;
        }
    }

    public static void main(String[] args) {
        OneShotLatch oneShotLatch = new OneShotLatch();
        for (int i = 0; i < 10; i++) {
            new Thread(new Runnable() {
                @Override
                public void run() {
                    System.out.println(Thread.currentThread().getName() + "尝试获取锁，获取失败就等待");
                    oneShotLatch.await();
                    System.out.println("开闸，" + Thread.currentThread().getName() + "继续运行");
                }
            }).start();
        }
        try {
            Thread.sleep(5200);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        oneShotLatch.signal();
        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName() + "尝试获取锁，获取失败就等待");
                oneShotLatch.await();
                System.out.println("开闸，" + Thread.currentThread().getName() + "继续运行");
            }
        }).start();

    }
}
```

注意： 编写AQS的线程协作器，基本都是有一定的套路



AQS补充材料（选修）

以下文章是关于AQS源码分析的，通常并不要求掌握，我找了一些优质学习资源，提供给小伙伴参考：

美团技术团队《从ReentrantLock的实现看AQS的原理及应用》：https://mp.weixin.qq.com/s/sA01gxC4EbgypCsQt5pVog

老钱《打通Java任督二脉——并发数据结构的基石》：https://juejin.im/post/5c11d6376fb9a049e82b6253HongJie《一行一行源码分析清楚AbstractQueuedSynchronizer》：https://javadoop.com/post/AbstractQueuedSynchronizer

爱吃鱼的KK《AbstractQueuedSynchronizer源码分析(基于Java 8)》：https://www.jianshu.com/p/e7659436538bwaterystone

《Java并发之AQS详解》：https://www.cnblogs.com/waterystone/p/4920797.html

英文论文的中文翻译：https://www.cnblogs.com/dennyzhangdd/p/7218510.htmlAQS

作者的英文论文：http://gee.cs.oswego.edu/dl/papers/aqs.pdf





# 10. 获取子线程的执行结果

## Future和Callable--治理线程的第二大法宝



### Runnable的缺陷

	- 不支持返回值
	- 也不能抛出checked Exception异常

为什么会这样设计？

​          run方法往上抛也是Thread类来接收，处理也不是我们来编写处理，所以抛出来我们也是无法处理

补救措施： 利用Callable接口



### Callable接口

类似于Runnable，被其他线程所执行，但是有返回值和异常

我们可以使用Future.get来获取Callable接口返回的执行结果，还可以通过Future.isDone来判断任务是否已经执行完了，以及取消这个任务，限时获取任务的结果等。

在call()未执行完毕，调用get()的线程（假定此时是主线程）会被阻塞，直到call()方法返回了结果后，此时future.get()方法才会得到应有的结果，然后主线程才会切换到runnable状态



**总结**： Future是一个存储器，它存储了call()这个任务的结果，而这个任务的执行时间是无法提前确定的，因为这完全取决于call()方法执行的情况。

实例如下：

```java
import java.util.Random;
import java.util.concurrent.*;

/**
 * @author leihfei
 * @date 2021-11-23 使用callable，future获取结果
 */
public class OneFuture {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService service = Executors.newFixedThreadPool(5);
        Future<Integer> submit = service.submit(new CallableTask());
        System.out.println(submit.get());
        service.shutdown();
    }

    static class CallableTask implements Callable<Integer> {
        @Override
        public Integer call() throws Exception {
            Thread.sleep(3000);
            return new Random().nextInt(100);
        }
    }
}
```

```java
import java.util.Random;
import java.util.concurrent.*;

/**
 * @author leihfei
 * @date 2021-11-23 使用callable，future获取结果
 */
public class OneFutureDemo2 {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService service = Executors.newFixedThreadPool(5);
        Callable callable = new Callable() {
            @Override
            public Object call() throws Exception {
                return new Random().nextInt();
            }
        };
        // Callable callable = () -> new Random().nextInt();
        Future<Integer> submit = service.submit(callable);
        System.out.println(submit.get());
        service.shutdown();
    }
}
```



### Future类

​	用法1： 线程池的submit方法返回Future对象

​	用法2： 用FutureTask来创建Future



#### Future主要方法：

​	1. get方法：获取结果，该行为取决于Callable的任务状态

		1. 任务正常完成：get方法会立即返回
		1. 任务尚未完成（任务还未开始或进行中）：get将会阻塞并直到任务完成
		1. 任务执行过程中抛出Exception，get方法会抛出ExecutionException: 这里抛出异常，是call执行时产生的那个异常，这个类型是java.util.concurrent.ExecutionException,无论call执行是抛出的异常是什么，最后get方法抛出的异常都是ExecutionException
		1. 任务被取消：get方法会抛出CancellationException
		1. 任务超时：get有一个重载方法，是传一个延时时间，如果时间到了还没有结果，get方法会抛出TimeoutException异常。



2. get(long timeout,TimeUnit unit): 有超时的获取结果

 	3. cancel方法: 取消任务
 	4. isDone方法：判断线程是否执行完毕，执行完毕不代表成功或者失败，比如有中断等，只是返回这个任务被完事，不会再被执行了
 	5. isCancelled方法： 判断任务是否被取消













