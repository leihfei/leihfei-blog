# 设计模式



## 1. 策略模式

策略模式：
    策略模式定义了算法族，分别封装起来，让他们之间可以相互调用，
    此模式让算法的变化独立于使用算法的客户。

代码解释：
    定义了飞行的行为，叫声的行为接口。
    分别使用不同能力的行为实现该接口，那么就拥有了该接口的能力。

定义鸭子的父类，每一种鸭子都将继承该鸭子类，鸭子类中拥有飞行，叫声的接口。
那么现在需要让每种鸭子手动的设置行为的接口实现，那么鸭子就拥有了什么行为。

OO基础：
    抽象，封装，多台，继承。

oo原则:
    封装变化，多用组合、少用继承，针对接口编程，不针对实现编程。

要点：
    知道OO基础，并不足以让你设计出良好的oo系统，

良好的OO设计必须具备可复用、可扩充、可维护三个特性。

模式让我们建造出良好的oo设计质量的系统

模式被认为是经历经验的oo设计经验。

模式不是代码，而是针对设计问题的通用解决方案，你可以把他们应用到特定的应用中。

模式不是被发明，而是被发现。

大多数的模式和原则，都着眼于软件变化的主题。

大多数的模式都允许系统局部改变独立于其他部分。

我们常把系统中会变化的部分抽离出来封装。

模式让开发人员之间共享的语言，能够最大化沟通的价值。





## 2. 代理模式

代理模式：
    为另一个对象提供一个替身或占位符以控制对这个对象的访问

代理模式：
    1. 防火墙代理
        控制网络资源的方位，保护主体免于“坏客户”的侵害
        
   2. 智能引用代理
        当主题被引用时，进行额外的动作

3. 缓存代理
    为开销大的运算结果提供暂时存储；它也允许多个客户共享结果，
    以减少计算或网络延迟

4. 同步代理
    在多线程的情况下为主题提供安全的访问

5. 复杂隐藏代理
    用来隐藏一个类的复杂集合的复杂度，并进行访问
    。有时候也称“外观代理",这不难理解，复杂隐藏代理和外观模式不一样的，因为代理
    是访问控制，外观模式是提供一组接口

6. 写入时复制代理
    用来控制对象的复制，方法是延迟对象的复制，直到客户真的需要为止，这是虚拟代理的辩题。
    
    
    
    java中代理实现

    1. 静态代理
        实现接口重写
    1. jdk动态代理
        java.lang.reflect.Proxy接口
    1. cglib代理
        第三方jar包实现





## 3.单例模式

  确保对象只有一个，并提供全局访问。

构造参数私有
对外提供一个对外获取对象的方法单例模式：
    1. 懒汉式
        需要用到才进行new对象
        
   2. 饿汉式
        加载类的时候就new对象
        private static Singeton sington = new Singeton()

   3. 单例模式优化：
            多线程情况下也会出现异常
            解决方式： 添加synchronized 同步代码块（添加在方法上）
                存在问题： 当获取单例对象的方法被频繁的调用，又会造成资源的锁定。
                再次优化： 使用饿汉式方法，加载类对象的时候就进行初始化值
            双重检查加锁法：
                在成员变量中添加volatile线程关键字
                在获取对象方法中判断两次实例对象，在两次中间添加synchorination方法进行锁定

             ```java
                public static Singleton getInstance(){
                         if(instance == null){
                             synchorization(Singleton.class){
                                 if(instance == null){
                                     instance = new Singleton();
                                 }
                             }
                         }
                         return instance;
                     }
             ```

​        

## 4. 迭代器模式：

提供一种方法可以顺序方位一个聚合对象中的各种对象。
提供一种方法顺序访问一个聚合对象中的各个元素，而且不暴露其内部
的表示。

把游走的任务放在迭代器上，而不是聚合上，这样简化了聚合的接口
和实现，也让责任各得其所。

单一责任原则：
    一个类应该只有一个引起变化的原因





## 5. 工厂模式Factory Pattern

定义了一个创建对象的接口，但由于子类决定要实例化的类是哪一个，工厂方法让类把实例化推迟到了之类。

工厂模式分类：
    1. 简单工厂模式
        设计方案：定义一个创建对象的类，由这个类来封装实例化对象。
          	定义接口，实现接口，定义工厂类： 传递不同的参数，进行创建不通的实现了接口的具体实现类。
       2. 工厂方法模式
        设计方案： 定义一个创建对象的抽象方法，由子类决定要实例化的类，工厂方法模式将对象的实例化推迟到了子类。
        定义一个具体接口，定义一个工厂方法，实现接口

```java
interface Phone
class XiaoMiFactoryPhone implement Phone
class PhoneFactoryPhone implement Phone
Phone phone = new XiaoMiFactoryPhone()
```

3. 抽象工厂模式
    设计方案： 定义了一个接口用于创建相关或有依赖关系的对象族，而无须明确指定具体类。
    
    

样例：
 披萨项目： 要方便披萨品种的扩展，要便于维护，要能运行时扩展。

 依赖抽象原则：
    变量不要持有具体类的引用
    不要让类继承自具体类，要继承自抽象类或者接口
    不要覆盖基类中已实现的方法



## 6. 观察者模式：

定义了对象之间一对多的依赖，这样依赖，当一个对象改变状态时，它的所有依赖者都会收到
通知并自动更新。

 项目说明：
    manual 包
        天气主题(Subject) ，subject是一个接口
            注册观察者，注销观察者，推送数据等
        观察者(Observer),observer 是一个接口
            包含一个更新update接口
        显示接口(DisplayElement),是一个接口
            就只包含了一个display方法
    在当前看板中，注册一个主题，再把当前看板作为一个观察者注册到主题中，那么主题中就包含了该观察者，
    那么在更新主题的时候循环调用了观察者的update方法更新观察者中的数据，从而进行显示。

使用java.util下的包
Observable（class），是一个类，类中维护一个Vector的向量，线程安全，还有一个chenged，是用于判断是
推送，还是观察者自动拉取。

Observer（interface),是一个接口，只有一个update方法，参数为(Observable,Object)

我们事先气象站的时候，必须在设置气象值之后进行手动调用notifyObservers(org)方法，这样就可以就行数据推送
到了看板。
在看板中实现接口，并且将看板(this)注册到气象站中,这样同一个气象站对象就拥有了观察者对象。
那么在主题需要推送数据的时候，观察者就可以得到数据了。


 在Observable类中，线程安全

观察者模式要点：
    观察者模式定义了对象之间的一对多关系

主题：也就是克观察者用一个共同的接口来更新观察者
观察者和可观察者之间用送耦合方式结合（loosecoupling),可观察者不知道观察者的细节，只知道观察者实现了观察者接口。

使用此模式时：你可从被从观察者出推(push)或拉(pull)数据(然而，推的方式被认为更正确)
有多个观察者时，不可以依赖特定的顺序的通知次序

Java有多个观察者模式的实现，包括了通用的java.utils.Observable

要注意java.util.Observable实现带来的一些问题(Observable是类)

如果有必要的话，可以实现自己的Observable，并不困难。

Swing大量使用观察者模式，许多GUI框架也是如此。





使用场合：
    定报纸 -> 出版社（主题） + 订阅者（观察者） = 观察者模式
    送牛奶 -> 牛奶厂 + 定奶者 = 观察者模式
    JaveBeans,RMI





## 7. 外观模式、门面模式：

提供一个统一的接口，来访问子系统中的一群功能相关的接口，外观模式定义了一个高层接口，让子类调用更方便。

最少知识原则：
    尽量减少对象之间的交互，只留几个“密友”，
    项目设计中就是不要让太多的类耦合在一起

如何遵循最少知识原则：
    对象的方法调用的范围：
      该对象本身
      作为参数传进来
      此方法创建和实例化的对象
      对象的组件

例子：
    组件一个家庭影院
    DVD播放器，投影仪，自动屏幕，环绕立体声，爆米花



## 8. 命令模式 Command Pattern

将请求，命令，动作等封装成对象，这样可以让项目使用这些对象来参数化其他
对象，使得命令的请求者和执行者解耦。




思路：
    定义一个命令接口，包括两个方法:excute(),undo()
    将硬件的开关是一种功能、动作
    比如将某个硬件的功能做成一个命令

   例子：
        遥控器控制灯的开关
        首先定义一个执行动作接口，执行什么功能，回退上一步
        灯有开，关的功能
        定义一个开灯的命令实现类，实现了执行动作接口-开灯
        定义一个关灯的命令实现类，实现了执行动作接口-关灯
        遥控器类有两个数组，一个是开灯，一个是关灯数组，
        当有一组灯的控制需要加入该遥控器，那么就push进来
        当要控制某个灯的开、关，那么就对应的调用遥控器的开，关，传入哪一组灯即可



## 9.模板模式：

封装了一个算法步骤，并允许子类为一个或多个步骤提供具体实现。
模板模式可以使子类不改变算法结构的情况下，重新定义算法中的某些步骤。

将理解： 步骤写成抽象类，相同的方法由抽象类定义，并且不允许修改，子类中实现具体的方法。

身边的模板模式：
    排序鸭子
        只能对对象排序，实现Complable接口

    自定义控件
    
    android中的控件

好莱坞原则：别调用我们，我们会调用你
    意义：高层无须知道调用底层的细节，解耦
        复杂系统，有的对象负责处理流程，有的对象只负责自己的业务。
    模板模式与好莱坞意义

模板模式的关键点：

例子：
    泡咖啡与泡茶的算法



## 10. 适配器模式

将一个类的接口转换成另一种接口，让原本接口不兼容的类可以兼容
分为：
       类适配器-适配器继承被适配对象，实现目标对象
       对象适配器-适配器实现目标对象，被适配对象为成员变量

 原理： 适配器必须实现或者继承目标接口 组合来实现
        通过多重继承，继承来实现

装饰者模式与适配器模式的区别：
    装饰者模式中的装饰者必须有相同的超类
    适配器的目标可以是目标类的子类


例子： 火鸡冒充鸭子



## 11. 装饰者模式；

动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案。

说明：
    在装饰中者，其实就是不同的类都必须继承同一个父类或者实现同一个接口，那么在运行时动态加载
    数据，层层包装，就会构成装饰者模式，最典型的就是java.io包下的InputStream等。

再次说明：
    装饰者模式就是集成或者实现同一个类，然后在装饰的同时把父类(装饰者/被装饰者)传递过去，在当前
    该装饰者中使用super来获取到父类的数据，在加上/减去当前类的操作或者直接替换到父类的操作。从而
    得到新的类数据。



要点：
    继承属于扩展形式之一，单不见得是达到弹性设计的最佳方案

在我们的设计中，应该允许行为可以被扩展，而无须修改现有代码

组合和委托可用于在运行时动态地加上新的行为

除了继承，装饰者模式也可以让我们扩展行为

装饰者模式意味着一群装饰者类，这些类用于包装具体组件

装饰者类反应出被装饰者的组件类型(事实上，他们具有相同的类型，都经过接口或继承实现)

装饰者可以在被装饰者的行为前面或者后面加上自己的行为，甚至将被装饰着的行为整个取代，而达到特定的目的

你可以用无所个装饰者包装一个组件

装饰者一般对组件的客户是透明的，除非客户程序依赖组件的具体类型

装饰者会导致设计中出现许多小对象，如果过度使用，会让程序变得很复杂



## 12. 状态模式：

允许对象在内部状态改变时更改它的行为，对象看起来好像
更改了它的类。


 解释：
    状态模式就是将if-else包装成各个对象，每个对象表示一种行为，
    或者说一种状态，行为的改变就是状态的改变。

实例：
    糖果机有投钱，转动曲柄，发放糖果，卖完了几个状态，
    那么我就就需要将这几个状态封装成方法，在不同方法中判断
    当前状态和其他状态的关系，才能决定到当前能做什么动作。

使用状态模式就是将每个状态封装成一个对象，实现或继承一个接口
（四种状态),在不同的状态中的各个状态方法中编写代码即可。



## 13. 组合模式：

允许你将对象组合成树形结构来表现“整体/部分"层次结构。组合能让客户以
一致的方式处理个别对象以及对象组合。


 组合模式让我们能用树形方式创建对象的结构，树里面包含了组合以及个别的对象。

 使用组合结构，我们能把相同的操作应用在组合和个别对象上。换句话说，在大多数情况下，我们可以忽略
 对象组合和个别对象之间的差别。