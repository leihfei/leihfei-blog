export const data = JSON.parse("{\"key\":\"v-457a2b78\",\"path\":\"/thread/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%AB%98%E7%BA%A7%E7%AC%94%E8%AE%B0.html\",\"title\":\"多线程高级笔记\",\"lang\":\"en-US\",\"frontmatter\":{},\"excerpt\":\"\",\"headers\":[{\"level\":2,\"title\":\"1. 创建和停止线程池\",\"slug\":\"_1-创建和停止线程池\",\"link\":\"#_1-创建和停止线程池\",\"children\":[{\"level\":3,\"title\":\"线程添加规则\",\"slug\":\"线程添加规则\",\"link\":\"#线程添加规则\",\"children\":[]},{\"level\":3,\"title\":\"增减线程的特点\",\"slug\":\"增减线程的特点\",\"link\":\"#增减线程的特点\",\"children\":[]},{\"level\":3,\"title\":\"线程池有哪几种工作队列？\",\"slug\":\"线程池有哪几种工作队列\",\"link\":\"#线程池有哪几种工作队列\",\"children\":[]},{\"level\":3,\"title\":\"线程创建JDK提供几种方式\",\"slug\":\"线程创建jdk提供几种方式\",\"link\":\"#线程创建jdk提供几种方式\",\"children\":[]},{\"level\":3,\"title\":\"设置线程池中的线程数多少合适?\",\"slug\":\"设置线程池中的线程数多少合适\",\"link\":\"#设置线程池中的线程数多少合适\",\"children\":[]},{\"level\":3,\"title\":\"线程是自动还是手动创建好？\",\"slug\":\"线程是自动还是手动创建好\",\"link\":\"#线程是自动还是手动创建好\",\"children\":[]}]},{\"level\":2,\"title\":\"2. 常见的线程池的特点和用法\",\"slug\":\"_2-常见的线程池的特点和用法\",\"link\":\"#_2-常见的线程池的特点和用法\",\"children\":[{\"level\":3,\"title\":\"参数情况\",\"slug\":\"参数情况\",\"link\":\"#参数情况\",\"children\":[]},{\"level\":3,\"title\":\"停止线程的正确方法\",\"slug\":\"停止线程的正确方法\",\"link\":\"#停止线程的正确方法\",\"children\":[]}]},{\"level\":2,\"title\":\"3. 拒绝策略\",\"slug\":\"_3-拒绝策略\",\"link\":\"#_3-拒绝策略\",\"children\":[]},{\"level\":2,\"title\":\"4. 钩子方法\",\"slug\":\"_4-钩子方法\",\"link\":\"#_4-钩子方法\",\"children\":[]},{\"level\":2,\"title\":\"5. 实现原理、源码分析\",\"slug\":\"_5-实现原理、源码分析\",\"link\":\"#_5-实现原理、源码分析\",\"children\":[]},{\"level\":2,\"title\":\"6. 使用线程池的注意点\",\"slug\":\"_6-使用线程池的注意点\",\"link\":\"#_6-使用线程池的注意点\",\"children\":[]},{\"level\":2,\"title\":\"7.  最佳实践\",\"slug\":\"_7-最佳实践\",\"link\":\"#_7-最佳实践\",\"children\":[]},{\"level\":2,\"title\":\"2.1 ThreadLocal使用场景\",\"slug\":\"_2-1-threadlocal使用场景\",\"link\":\"#_2-1-threadlocal使用场景\",\"children\":[]},{\"level\":2,\"title\":\"2.2 源码\",\"slug\":\"_2-2-源码\",\"link\":\"#_2-2-源码\",\"children\":[]},{\"level\":2,\"title\":\"2.3 重要方法\",\"slug\":\"_2-3-重要方法\",\"link\":\"#_2-3-重要方法\",\"children\":[]},{\"level\":2,\"title\":\"2.4 内存泄漏\",\"slug\":\"_2-4-内存泄漏\",\"link\":\"#_2-4-内存泄漏\",\"children\":[]},{\"level\":2,\"title\":\"3.1 Lock接口\",\"slug\":\"_3-1-lock接口\",\"link\":\"#_3-1-lock接口\",\"children\":[]},{\"level\":2,\"title\":\"3.2 锁的分类\",\"slug\":\"_3-2-锁的分类\",\"link\":\"#_3-2-锁的分类\",\"children\":[]},{\"level\":2,\"title\":\"3.3 乐观锁和悲观锁\",\"slug\":\"_3-3-乐观锁和悲观锁\",\"link\":\"#_3-3-乐观锁和悲观锁\",\"children\":[]},{\"level\":2,\"title\":\"3.4 可重入锁和非可重入锁，以ReentrantLock\",\"slug\":\"_3-4-可重入锁和非可重入锁-以reentrantlock\",\"link\":\"#_3-4-可重入锁和非可重入锁-以reentrantlock\",\"children\":[]},{\"level\":2,\"title\":\"3.5 公平锁和非公平锁\",\"slug\":\"_3-5-公平锁和非公平锁\",\"link\":\"#_3-5-公平锁和非公平锁\",\"children\":[]},{\"level\":2,\"title\":\"3.6 共享锁和排他锁： 以ReentrantReadWriteLock读写锁\",\"slug\":\"_3-6-共享锁和排他锁-以reentrantreadwritelock读写锁\",\"link\":\"#_3-6-共享锁和排他锁-以reentrantreadwritelock读写锁\",\"children\":[]},{\"level\":2,\"title\":\"3.7 自旋锁和阻塞锁\",\"slug\":\"_3-7-自旋锁和阻塞锁\",\"link\":\"#_3-7-自旋锁和阻塞锁\",\"children\":[]},{\"level\":2,\"title\":\"3.8 可中断锁： 就是可以响应中断的锁\",\"slug\":\"_3-8-可中断锁-就是可以响应中断的锁\",\"link\":\"#_3-8-可中断锁-就是可以响应中断的锁\",\"children\":[]},{\"level\":2,\"title\":\"3.9 锁优化\",\"slug\":\"_3-9-锁优化\",\"link\":\"#_3-9-锁优化\",\"children\":[]},{\"level\":2,\"title\":\"4.1 什么是原子类，有什么作用？\",\"slug\":\"_4-1-什么是原子类-有什么作用\",\"link\":\"#_4-1-什么是原子类-有什么作用\",\"children\":[]},{\"level\":2,\"title\":\"4.2 6类原子类\",\"slug\":\"_4-2-6类原子类\",\"link\":\"#_4-2-6类原子类\",\"children\":[]},{\"level\":2,\"title\":\"4.3 Atiomic*基本类型原子类\",\"slug\":\"_4-3-atiomic-基本类型原子类\",\"link\":\"#_4-3-atiomic-基本类型原子类\",\"children\":[]},{\"level\":2,\"title\":\"4.4 Atomic*Array数组类原子类\",\"slug\":\"_4-4-atomic-array数组类原子类\",\"link\":\"#_4-4-atomic-array数组类原子类\",\"children\":[]},{\"level\":2,\"title\":\"4.5 Atomic*Reference引用类型原子类\",\"slug\":\"_4-5-atomic-reference引用类型原子类\",\"link\":\"#_4-5-atomic-reference引用类型原子类\",\"children\":[]},{\"level\":2,\"title\":\"4.6 把普通变量升级为原子类，用AtomicIntegerFiledUpdater升级原有变量\",\"slug\":\"_4-6-把普通变量升级为原子类-用atomicintegerfiledupdater升级原有变量\",\"link\":\"#_4-6-把普通变量升级为原子类-用atomicintegerfiledupdater升级原有变量\",\"children\":[]},{\"level\":2,\"title\":\"4.7  Adder累加器\",\"slug\":\"_4-7-adder累加器\",\"link\":\"#_4-7-adder累加器\",\"children\":[]},{\"level\":2,\"title\":\"4.8 Accumulator累加器\",\"slug\":\"_4-8-accumulator累加器\",\"link\":\"#_4-8-accumulator累加器\",\"children\":[{\"level\":3,\"title\":\"1. 什么是CAS\",\"slug\":\"_1-什么是cas\",\"link\":\"#_1-什么是cas\",\"children\":[]},{\"level\":3,\"title\":\"2. CAS使用场景\",\"slug\":\"_2-cas使用场景\",\"link\":\"#_2-cas使用场景\",\"children\":[]},{\"level\":3,\"title\":\"3.总结\",\"slug\":\"_3-总结\",\"link\":\"#_3-总结\",\"children\":[]}]},{\"level\":2,\"title\":\"7.1 概览\",\"slug\":\"_7-1-概览\",\"link\":\"#_7-1-概览\",\"children\":[]},{\"level\":2,\"title\":\"7.2 集合类的历史\",\"slug\":\"_7-2-集合类的历史\",\"link\":\"#_7-2-集合类的历史\",\"children\":[]},{\"level\":2,\"title\":\"7.3 Map接口\",\"slug\":\"_7-3-map接口\",\"link\":\"#_7-3-map接口\",\"children\":[]},{\"level\":2,\"title\":\"7.4 HashMap的死循环，CPU100%问题\",\"slug\":\"_7-4-hashmap的死循环-cpu100-问题\",\"link\":\"#_7-4-hashmap的死循环-cpu100-问题\",\"children\":[]},{\"level\":2,\"title\":\"7.5 HashMap特点\",\"slug\":\"_7-5-hashmap特点\",\"link\":\"#_7-5-hashmap特点\",\"children\":[]},{\"level\":2,\"title\":\"7.6 ConcurrentHashMap在Java7/8版本的区别\",\"slug\":\"_7-6-concurrenthashmap在java7-8版本的区别\",\"link\":\"#_7-6-concurrenthashmap在java7-8版本的区别\",\"children\":[]},{\"level\":2,\"title\":\"7.7 组合操作不保证线程安全\",\"slug\":\"_7-7-组合操作不保证线程安全\",\"link\":\"#_7-7-组合操作不保证线程安全\",\"children\":[]},{\"level\":2,\"title\":\"7.8 CopyOnWriteArrayList\",\"slug\":\"_7-8-copyonwritearraylist\",\"link\":\"#_7-8-copyonwritearraylist\",\"children\":[]},{\"level\":2,\"title\":\"7.9 并发队列Queue：阻塞队列\",\"slug\":\"_7-9-并发队列queue-阻塞队列\",\"link\":\"#_7-9-并发队列queue-阻塞队列\",\"children\":[{\"level\":3,\"title\":\"ArrayBlockingQueue\",\"slug\":\"arrayblockingqueue\",\"link\":\"#arrayblockingqueue\",\"children\":[]},{\"level\":3,\"title\":\"LinkedBlockingQueue\",\"slug\":\"linkedblockingqueue\",\"link\":\"#linkedblockingqueue\",\"children\":[]},{\"level\":3,\"title\":\"PriorityBlockingQueue\",\"slug\":\"priorityblockingqueue\",\"link\":\"#priorityblockingqueue\",\"children\":[]},{\"level\":3,\"title\":\"SynchronousQueue\",\"slug\":\"synchronousqueue\",\"link\":\"#synchronousqueue\",\"children\":[]},{\"level\":3,\"title\":\"DelayQueue\",\"slug\":\"delayqueue\",\"link\":\"#delayqueue\",\"children\":[]},{\"level\":3,\"title\":\"非阻塞并发队列：ConcurrentLinkedQueue\",\"slug\":\"非阻塞并发队列-concurrentlinkedqueue\",\"link\":\"#非阻塞并发队列-concurrentlinkedqueue\",\"children\":[]},{\"level\":3,\"title\":\"总结\",\"slug\":\"总结\",\"link\":\"#总结\",\"children\":[]}]},{\"level\":2,\"title\":\"8.1 CountDownLatch 倒计时门栓\",\"slug\":\"_8-1-countdownlatch-倒计时门栓\",\"link\":\"#_8-1-countdownlatch-倒计时门栓\",\"children\":[]},{\"level\":2,\"title\":\"8.2 Semaphore 信号量\",\"slug\":\"_8-2-semaphore-信号量\",\"link\":\"#_8-2-semaphore-信号量\",\"children\":[]},{\"level\":2,\"title\":\"8.3 Condition接口，又称为条件对象\",\"slug\":\"_8-3-condition接口-又称为条件对象\",\"link\":\"#_8-3-condition接口-又称为条件对象\",\"children\":[]},{\"level\":2,\"title\":\"8.4 CyclicBarrier 循环栅栏\",\"slug\":\"_8-4-cyclicbarrier-循环栅栏\",\"link\":\"#_8-4-cyclicbarrier-循环栅栏\",\"children\":[]},{\"level\":2,\"title\":\"Future和Callable--治理线程的第二大法宝\",\"slug\":\"future和callable-治理线程的第二大法宝\",\"link\":\"#future和callable-治理线程的第二大法宝\",\"children\":[{\"level\":3,\"title\":\"Runnable的缺陷\",\"slug\":\"runnable的缺陷\",\"link\":\"#runnable的缺陷\",\"children\":[]},{\"level\":3,\"title\":\"Callable接口\",\"slug\":\"callable接口\",\"link\":\"#callable接口\",\"children\":[]},{\"level\":3,\"title\":\"Future类\",\"slug\":\"future类\",\"link\":\"#future类\",\"children\":[]}]}],\"git\":{},\"filePathRelative\":\"thread/多线程高级笔记.md\"}")

if (import.meta.webpackHot) {
  import.meta.webpackHot.accept()
  if (__VUE_HMR_RUNTIME__.updatePageData) {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  }
}

if (import.meta.hot) {
  import.meta.hot.accept(({ data }) => {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  })
}
